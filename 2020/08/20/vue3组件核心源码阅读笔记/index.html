<!DOCTYPE html>
<html lang="zh-Hans,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iiicon.github.io","root":"/blog/","scheme":"Pisces","version":"8.0.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Vue.js 的优化Vue 3.0 从源码、性能和语法 API 三个大的方面优化了框架，也提高了开发人员的开发体验，相比于 2.x 有了很大的一个改变">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3 组件核心源码阅读笔记">
<meta property="og:url" content="https://iiicon.github.io/blog-next/2020/08/20/vue3%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="之哥的荣耀">
<meta property="og:description" content="Vue.js 的优化Vue 3.0 从源码、性能和语法 API 三个大的方面优化了框架，也提高了开发人员的开发体验，相比于 2.x 有了很大的一个改变">
<meta property="og:locale">
<meta property="article:published_time" content="2020-08-20T02:03:35.000Z">
<meta property="article:modified_time" content="2021-12-21T06:04:02.321Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="vue3">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://iiicon.github.io/blog-next/2020/08/20/vue3%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>vue3 组件核心源码阅读笔记 | 之哥的荣耀</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-108155018-3"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-108155018-3');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="之哥的荣耀" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">之哥的荣耀</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">懒是一种美德</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-bell fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-plugins">

    <a href="/blog/plugins/" rel="section"><i class="fa fa-flask fa-fw"></i>Plugins</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">127</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">56</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">17</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue-js-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">Vue.js 的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">源码优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-API-%E4%BC%98%E5%8C%96%EF%BC%9AComposition-API"><span class="nav-number">1.3.</span> <span class="nav-text">语法 API 优化：Composition API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-RFC%EF%BC%9A%E4%BD%BF%E6%AF%8F%E4%B8%AA%E7%89%88%E6%9C%AC%E6%94%B9%E5%8A%A8%E5%8F%AF%E6%8E%A7"><span class="nav-number">1.4.</span> <span class="nav-text">引入 RFC：使每个版本改动可控</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9AVue-%E6%A0%B8%E5%BF%83%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">组件的实现：Vue 核心的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vnode-%E5%88%B0%E7%9C%9F%E5%AE%9E-DOM-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">vnode 到真实 DOM 是如何转变的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.1.</span> <span class="nav-text">vue 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-app-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. 创建 app 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%87%8D%E5%86%99-app-mount-%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2. 重写 app.mount 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%9A%E5%88%9B%E5%BB%BA-vnode-%E5%92%8C%E6%B8%B2%E6%9F%93-vnode"><span class="nav-number">2.1.2.</span> <span class="nav-text">核心渲染流程：创建 vnode 和渲染 vnode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-vnode"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">创建 vnode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93-vnode"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">渲染 vnode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%EF%BC%9A%E5%AE%8C%E6%95%B4%E7%9A%84-DOM-diff-%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">组件更新：完整的 DOM diff 流程是怎样的？（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E6%9B%B4%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">副作用渲染函数更新组件的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83-patch"><span class="nav-number">2.2.2.</span> <span class="nav-text">核心 patch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BB%84%E4%BB%B6"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">处理组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">处理普通元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%EF%BC%9A%E5%AE%8C%E6%95%B4%E7%9A%84-DOM-diff-%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">组件更新：完整的 DOM diff 流程是怎样的？（下）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%B4%E9%83%A8%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.1.</span> <span class="nav-text">同步头部节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B0%BE%E9%83%A8%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.2.</span> <span class="nav-text">同步尾部节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">添加新节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.4.</span> <span class="nav-text">删除多余节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%AA%E7%9F%A5%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.3.5.</span> <span class="nav-text">处理未知子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE-key-%E5%BB%BA%E7%AB%8B%E6%96%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E7%B4%A2%E5%BC%95%E5%9B%BE"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">根据 key 建立新子序列的索引图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E7%A7%BB%E9%99%A4%E6%97%A7%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">更新和移除旧节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%8C%82%E8%BD%BD%E6%96%B0%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">移动和挂载新节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GerritV"
      src="/blog/images/logo.svg">
  <p class="site-author-name" itemprop="name">GerritV</p>
  <div class="site-description" itemprop="description">别坚持做没用的事情</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbg==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iiicon"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/shiguangwei5@gmail.com" title="E-Mail → shiguangwei5@gmail.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zZ3cud2lraS8=" title="blog → https:&#x2F;&#x2F;sgw.wiki&#x2F;"><i class="fab fa-gitter fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>


<div class="cc-license animated" itemprop="sponsor">
</div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0" title="Fork NexT on GitHub" aria-label="Fork NexT on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://iiicon.github.io/blog-next/2020/08/20/vue3%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/logo.svg">
      <meta itemprop="name" content="GerritV">
      <meta itemprop="description" content="别坚持做没用的事情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="之哥的荣耀">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          vue3 组件核心源码阅读笔记<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbl9wb3N0cy92dWUz57uE5Lu25qC45b+D5rqQ56CB6ZiF6K+756yU6K6wLm1k" title="Edit this post"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-08-20 10:03:35" itemprop="dateCreated datePublished" datetime="2020-08-20T10:03:35+08:00">2020-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Vue-js-的优化"><a href="#Vue-js-的优化" class="headerlink" title="Vue.js 的优化"></a>Vue.js 的优化</h1><p>Vue 3.0 从源码、性能和语法 API 三个大的方面优化了框架，也提高了开发人员的开发体验，相比于 2.x 有了很大的一个改变</p>
<a id="more"></a>

<h2 id="源码优化"><a href="#源码优化" class="headerlink" title="源码优化"></a>源码优化</h2><ul>
<li>更好的代码管理方式：monorepo</li>
<li>有类型的 JavaScript：TypeScript</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li><p>源码体积优化</p>
<ul>
<li>首先，移除一些冷门的 feature（比如 filter、inline-template 等）</li>
<li>其次，引入 tree-shaking 的技术，减少打包体积</li>
</ul>
</li>
<li><p>数据劫持优化</p>
</li>
<li><p>编译优化，借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破</p>
</li>
</ul>
<h2 id="语法-API-优化：Composition-API"><a href="#语法-API-优化：Composition-API" class="headerlink" title="语法 API 优化：Composition API"></a>语法 API 优化：Composition API</h2><ol>
<li>优化逻辑组织</li>
<li>优化逻辑复用</li>
</ol>
<h2 id="引入-RFC：使每个版本改动可控"><a href="#引入-RFC：使每个版本改动可控" class="headerlink" title="引入 RFC：使每个版本改动可控"></a>引入 RFC：使每个版本改动可控</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JmY3MvcHVsbHM/cT1pczpwcitpczptZXJnZWQrbGFiZWw6My54">Vue.js-RFC<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="组件的实现：Vue-核心的实现"><a href="#组件的实现：Vue-核心的实现" class="headerlink" title="组件的实现：Vue 核心的实现"></a>组件的实现：Vue 核心的实现</h1><blockquote>
<p>模板 + 对象描述 + 数据 = 组件</p>
</blockquote>
<h2 id="vnode-到真实-DOM-是如何转变的？"><a href="#vnode-到真实-DOM-是如何转变的？" class="headerlink" title="vnode 到真实 DOM 是如何转变的？"></a>vnode 到真实 DOM 是如何转变的？</h2><blockquote>
<p>创建 vnode + 渲染 vnode + 生成 DOM</p>
</blockquote>
<h3 id="vue-初始化"><a href="#vue-初始化" class="headerlink" title="vue 初始化"></a>vue 初始化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Vue.js 3.0 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./app&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.mount(<span class="string">&quot;#app&quot;</span>); <span class="comment">// 把 App 组件挂载到 id 为 app 的 DOM 节点上</span></span><br></pre></td></tr></table></figure>

<p>这其中导入了一个 createApp 入口函数，他是 Vue.js 对外暴露的一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 app 对象</span></span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args);</span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app;</span><br><span class="line">  <span class="comment">// 重写 mount 方法</span></span><br><span class="line">  app.mount = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出 createApp 主要做了两件事情，创建 app 对象和重写 app.mount 方法</p>
<h4 id="1-创建-app-对象"><a href="#1-创建-app-对象" class="headerlink" title="1. 创建 app 对象"></a>1. 创建 app 对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = ensureRenderer().createApp(...args);</span><br></pre></td></tr></table></figure>

<p>其中 ensureRenderer() 用来创建一个渲染器对象，它的内部实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法</span></span><br><span class="line"><span class="keyword">const</span> rendererOptions = &#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  ...nodeOps,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderer || (renderer = createRenderer(rendererOptions));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer(options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 组件渲染的核心逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    <span class="attr">createApp</span>: createAppAPI(render),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>(<span class="params">render</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createApp createApp 方法接受的两个参数：根组件的对象和 prop</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = &#123;</span><br><span class="line">      <span class="attr">_component</span>: rootComponent,</span><br><span class="line">      <span class="attr">_props</span>: rootProps,</span><br><span class="line">      <span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps);</span><br><span class="line">        <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line">        render(vnode, rootContainer);</span><br><span class="line">        app._container = rootContainer;</span><br><span class="line">        <span class="keyword">return</span> vnode.component.proxy;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-重写-app-mount-方法"><a href="#2-重写-app-mount-方法" class="headerlink" title="2. 重写 app.mount 方法"></a>2. 重写 app.mount 方法</h4><p>Vue.js 不仅仅是为 Web 平台服务，它的目标是支持跨平台渲染，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line"> <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line"> <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line"> render(vnode, rootContainer)</span><br><span class="line"> app._container = rootContainer</span><br><span class="line"> <span class="keyword">return</span> vnode.component.proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准的跨平台渲染流程是先创建 vnode，再渲染 vnode。此外参数 rootContainer 也可以是不同类型的值，也就是这里是通用的渲染逻辑，<br>接下来完善 Web 平台下的渲染逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.mount = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 标准化容器</span></span><br><span class="line">  <span class="keyword">const</span> container = normalizeContainer(containerOrSelector);</span><br><span class="line">  <span class="keyword">if</span> (!container) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> component = app._component;</span><br><span class="line">  <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">  <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">    component.template = container.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载前清空容器内容</span></span><br><span class="line">  container.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 真正的挂载</span></span><br><span class="line">  <span class="keyword">return</span> mount(container);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>app.mount 就是 重写的 mount 方法，传入 container 参数，先标准化容器，然后取出 rootComponent，<br>如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容，<br>在挂载前清空容器内容，然后执行通用的 mount 方法</p>
<h3 id="核心渲染流程：创建-vnode-和渲染-vnode"><a href="#核心渲染流程：创建-vnode-和渲染-vnode" class="headerlink" title="核心渲染流程：创建 vnode 和渲染 vnode"></a>核心渲染流程：创建 vnode 和渲染 vnode</h3><h4 id="创建-vnode"><a href="#创建-vnode" class="headerlink" title="创建 vnode"></a>创建 vnode</h4><p>组件 vnode 其实是对抽象事物的描述，这是因为我们并不会在页面上真正渲染一个 <code>&lt;custom-component&gt;</code> 标签，而是渲染组件内部定义的 HTML 标签。<br>vnode 有组件 vnode，普通元素 vnode，注释 vnode，文本 vnode</p>
<p><strong>为什么要设计 vnode？</strong></p>
<ul>
<li>抽象</li>
<li>跨平台都可以用</li>
</ul>
<p>回顾 app.mount 内部实现，用 createVnode 创建了根组件的 vnode</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props = <span class="literal">null</span>, children = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props 相关逻辑，标准化 class 和 style</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 vnode 类型信息编码</span></span><br><span class="line">  <span class="keyword">const</span> shapeFlag = isString(type)</span><br><span class="line">    ? <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">    : isSuspense(type)</span><br><span class="line">    ? <span class="number">128</span> <span class="comment">/* SUSPENSE */</span></span><br><span class="line">    : isTeleport(type)</span><br><span class="line">    ? <span class="number">64</span> <span class="comment">/* TELEPORT */</span></span><br><span class="line">    : isObject(type)</span><br><span class="line">    ? <span class="number">4</span> <span class="comment">/* STATEFUL_COMPONENT */</span></span><br><span class="line">    : isFunction(type)</span><br><span class="line">    ? <span class="number">2</span> <span class="comment">/* FUNCTIONAL_COMPONENT */</span></span><br><span class="line">    : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    <span class="comment">// 一些其他属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 标准化子节点，把不同数据类型的 children 转成数组或者文本类型</span></span><br><span class="line">  normalizeChildren(vnode, children);</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 createVnode 就是对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children，返回 vnode</p>
<h4 id="渲染-vnode"><a href="#渲染-vnode" class="headerlink" title="渲染 vnode"></a>渲染 vnode</h4><p>在 app.mount 内部通过 render(vnode, rootContainer) 去渲染组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render(vnode, rootContainer);</span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁组件</span></span><br><span class="line">    <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">      unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或者更新组件</span></span><br><span class="line">    patch(container._vnode || <span class="literal">null</span>, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 vnode 判断去执行卸载还是创建或更新，接下来看 patch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1);</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    n1 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Text:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Comment:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Static:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们重点关注对组件的处理和对普通 dom 元素的处理<br>先看对组件的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">    mountComponent(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新组件</span></span><br><span class="line">    updateComponent(n1, n2, parentComponent, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mountComponent 就做三件事情</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.component = createComponentInstance(</span><br><span class="line">    initialVNode,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense</span><br><span class="line">  ));</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  setupComponent(instance);</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>组件的创建不像 2.0 去实例化组件，内部通过返回对象创建，接着是设置组件实例，保留了很多组件相关的数据，维护了组件的上下文，包括对 props，插槽，以及其他实例的属性的初始化处理，最后是运行带副作用的渲染函数 <code>setupRenderEffect</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件生成子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance));</span><br><span class="line">      <span class="comment">// 把子树 vnode 挂载到 container 中</span></span><br><span class="line">      patch(<span class="literal">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG);</span><br><span class="line">      <span class="comment">// 保留渲染生成的子树根 DOM 节点</span></span><br><span class="line">      initialVNode.el = subTree.el;</span><br><span class="line">      instance.isMounted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该函数利用响应式库的 <code>effect</code> 函数创建了一个副作用渲染函数 <code>componentEffect</code>，当组件的数据发生变化时，<code>effect</code> 函数包裹的内部渲染函数 <code>componentEffect</code> 会重新执行一遍，从而达到重新渲染组件的目的。</p>
<p>先分析初始渲染</p>
<p><strong>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中</strong></p>
<p><code>initialVnode</code> 就是 <code>组件 vnode</code>，<code>subTree</code> 就是 <code>子树 vnode</code> 执行 <code>renderComponentRoot</code> 生成</p>
<p>我们知道每个组件都会有对应的 <code>render</code> 函数，即使你写 <code>template</code>，也会编译成 <code>render</code> 函数，而 <code>renderComponentRoot</code> 函数就是去执行 <code>render</code> 函数创建整个组件树内部的 <code>vnode</code>，把这个 <code>vnode</code> 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode。</p>
<p>渲染成子树 <code>vnode</code> 后，接下来就是继续调用 <code>patch</code> 函数把子树 <code>vnode</code> 挂载到 <code>container</code> 中</p>
<p>又回到 <code>patch</code> 函数，会继续对这个子树的 <code>vnode</code> 类型进行判断，如果是 <code>div</code> 就对应的是 <code>普通元素 vnode</code>，<br>就会处理普通 dom 执行 <code>processElement</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">&quot;svg&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    mountElement(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来看 mountElement 的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is);</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况 循环执行 child patch</span></span><br><span class="line">    mountChildren(</span><br><span class="line">      vnode.children,</span><br><span class="line">      el,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG &amp;&amp; type !== <span class="string">&quot;foreignObject&quot;</span>,</span><br><span class="line">      optimized || !!vnode.dynamicChildren</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，挂载元素函数主要做四件事情，创建 <code>DOM</code> 元素节点，处理 <code>props</code>，处理 <code>children</code>，挂载 <code>DOM</code> 到 container 上</p>
<p>渲染完 <code>subTree</code> 之后，就会执行 <code>componentEffect</code> 函数中的剩余逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initialVNode.el = subTree.el;</span><br><span class="line">instance.isMounted = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="组件更新：完整的-DOM-diff-流程是怎样的？（上）"><a href="#组件更新：完整的-DOM-diff-流程是怎样的？（上）" class="headerlink" title="组件更新：完整的 DOM diff 流程是怎样的？（上）"></a>组件更新：完整的 DOM diff 流程是怎样的？（上）</h2><h3 id="副作用渲染函数更新组件的过程"><a href="#副作用渲染函数更新组件的过程" class="headerlink" title="副作用渲染函数更新组件的过程"></a>副作用渲染函数更新组件的过程</h3><p>带副作用的渲染函数 <code>setupRenderEffect</code> 会在 instance.update 上挂载 <code>componentEffect</code> 函数，数据变化后就会执行该函数的 <code>else</code> 逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, vnode &#125; = instance;</span><br><span class="line">      <span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">        updateComponentPreRender(instance, next, optimized);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = vnode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 渲染新的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> nextTree = renderComponentRoot(instance);</span><br><span class="line">      <span class="comment">// 缓存旧的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.subTree;</span><br><span class="line">      <span class="comment">// 更新子树 vnode</span></span><br><span class="line">      instance.subTree = nextTree;</span><br><span class="line">      <span class="comment">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch</span></span><br><span class="line">      patch(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        <span class="comment">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点</span></span><br><span class="line">        hostParentNode(prevTree.el),</span><br><span class="line">        <span class="comment">// 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点</span></span><br><span class="line">        getNextHostNode(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 缓存更新后的 DOM 节点</span></span><br><span class="line">      next.el = nextTree.el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，更新组件主要做三件事情：更新组件 <code>vnode</code> 节点，渲染新的子树 <code>vnode</code> 根据新旧子树 <code>vnode</code> 执行 <code>patch</code> 逻辑</p>
<p>更新组件 <code>vnode</code> 的时候，要判断有没有新组件 <code>vnode</code> <code>next</code>，有则更新，没有就用之前的 <code>vnode</code><br>渲染新的子树 <code>vnode</code> 和之前的一样<br>最后就是核心的 <code>patch</code> 逻辑，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM</p>
<h3 id="核心-patch"><a href="#核心-patch" class="headerlink" title="核心 patch"></a>核心 patch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1);</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// n1 设置为 null 保证后续都走 mount 逻辑</span></span><br><span class="line">    n1 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Text:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Comment:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Static:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNodeType</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// n1 和 n2 节点的 type 和 key 都相同，才是相同节点</span></span><br><span class="line">  <span class="keyword">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中，首先判断新旧节点是否是相同的 <code>vnode</code> 类型，如果不同，比如一个 <code>div</code> 更新成一个 <code>ul</code>，那么最简单的操作就是删除旧的 <code>div</code> 节点，再去挂载新的 <code>ul</code> 节点</p>
<p>如果是相同的 <code>vnode</code>，那就要走 <code>diff</code> 更新流程了，接着会根据不同的 <code>vnode</code> 类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程</p>
<h4 id="处理组件"><a href="#处理组件" class="headerlink" title="处理组件"></a>处理组件</h4><p>如何处理组件的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an app.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">msg</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="title">toggle</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.msg = <span class="built_in">this</span>.msg ==== <span class="string">&#x27;Vue&#x27;</span>? <span class="string">&#x27;World&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">msg</span>: <span class="built_in">String</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的 msg，并且会触发 App 组件的重新渲染</p>
<p>结合前面对渲染流程的分析，这里的 App 组件的根节点是 div，重新渲染的子树 vnode 节点是一个普通元素的 vnode，应该先走 processElement 逻辑，组件的更新最终还是要转换成真实的 DOM 更新<br>而实际上普通元素的处理才是 DOM 的更新<br>和渲染流程相似，更新过程也是一个树的深度优先遍历的过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到 hello 这个 组件 vnode 节点，就会执行到 processComponent 的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新子组件</span></span><br><span class="line">    updateComponent(n1, n2, parentComponent, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> updateComponent = <span class="function">(<span class="params">n1, n2, parentComponent, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = (n2.component = n1.component);</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">  <span class="keyword">if</span> (shouldUpdateComponent(n1, n2, parentComponent, optimized)) &#123;</span><br><span class="line">    <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">    instance.next = n2;</span><br><span class="line">    <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    invalidateJob(instance.update);</span><br><span class="line">    <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">    instance.update();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要更新，只复制属性</span></span><br><span class="line">    n2.component = n1.component;</span><br><span class="line">    n2.el = n1.el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>processComponent</code> 通过 <code>updateComponent</code> 函数来更新组件，<code>updateComponent</code> 函数在更新子组件的时候，会先执行 <code>shouldUpdateComponent</code> 函数，根据新旧子组件 <code>vnode</code> 来判断是否需要更新子组件<br>如果 <code>shouldUpdateComponent</code> 返回 true， 那么在它的最后先执行<code> invalidateJob（instance.update）</code>避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数 <code>instance.update</code> 来主动触发子组件的更新</p>
<p>然后再到 <code>setupRenderEffect</code> 函数的 <code>update</code> 逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新组件</span></span><br><span class="line"><span class="keyword">let</span> &#123; next, vnode &#125; = instance;</span><br><span class="line"><span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line"><span class="keyword">if</span> (next) &#123;</span><br><span class="line">  <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">  updateComponentPreRender(instance, next, optimized);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  next = vnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> updateComponentPreRender = <span class="function">(<span class="params">instance, nextVNode, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.component = instance;</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.vnode.props;</span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.vnode = nextVNode;</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  updateProps(instance, nextVNode.props, prevProps, optimized);</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  updateSlots(instance, nextVNode.children);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合上面的代码，我们在更新组件的 <code>DOM</code> 前，需要先更新组件 <code>vnode</code> 节点信息，包括更改组件实例的 <code>vnode</code> 指针、更新 <code>props</code> 和更新插槽等一系列操作，因为组件在稍后执行 <code>renderComponentRoot</code> 时会重新渲染新的子树 <code>vnode</code> ，它依赖了更新后的组件 <code>vnode</code> 中的 <code>props</code> 和 <code>slots</code> 等数据。</p>
<p>所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下 <code>next</code> 是 <code>null</code>；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下 <code>next</code> 就是新的子组件 <code>vnode</code></p>
<p>所以 <code>processComponent</code> 处理组件 <code>vnode</code>，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些 <code>vnode</code> 的属性，并让子组件实例保留对组件 <code>vnode</code> 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 <code>vnode</code></p>
<p>前面也说过，组件是抽象的，组件的更新最终还是会落到对普通 <code>DOM</code> 元素的更新。所以接下来我们详细分析一下组件更新中对普通元素的处理流程</p>
<h4 id="处理普通元素"><a href="#处理普通元素" class="headerlink" title="处理普通元素"></a>处理普通元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">&quot;svg&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新元素</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> patchElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">  <span class="keyword">const</span> oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ;</span><br><span class="line">  <span class="keyword">const</span> newProps = n2.props || EMPTY_OBJ;</span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  patchProps(</span><br><span class="line">    el,</span><br><span class="line">    n2,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> areChildrenSVG = isSVG &amp;&amp; n2.type !== <span class="string">&quot;foreignObject&quot;</span>;</span><br><span class="line">  <span class="comment">// 更新子节点</span></span><br><span class="line">  patchChildren(</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    el,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    areChildrenSVG</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，更新元素的过程主要做两件事情：更新 <code>props</code> 和更新子节点。其实这是很好理解的，因为一个 <code>DOM</code> 节点元素就是由它自身的一些属性和子节点构成的。</p>
<p>首先是更新 <code>props</code>，这里的 <code>patchProps</code> 函数就是在更新 <code>DOM</code> 节点的 <code>class、style、event</code> 以及其它的一些 <code>DOM</code> 属性</p>
<p>其次是更新子节点，我们来看一下这里的 <code>patchChildren</code> 函数的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.children;</span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> c2 = n2.children;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = n2;</span><br><span class="line">  <span class="comment">// 子节点有 3 种可能情况：文本、数组、空</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 数组 -&gt; 文本，则删除之前的子节点</span></span><br><span class="line">      unmountChildren(c1, parentComponent, parentSuspense);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">      <span class="comment">// 文本对比不同，则替换为新文本</span></span><br><span class="line">      hostSetElementText(container, c2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是数组</span></span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 新的子节点仍然是数组，则做完整地 diff</span></span><br><span class="line">        patchKeyedChildren(</span><br><span class="line">          c1,</span><br><span class="line">          c2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组 -&gt; 空，则仅仅删除之前的子节点</span></span><br><span class="line">        unmountChildren(c1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是文本节点或者为空</span></span><br><span class="line">      <span class="comment">// 新的子节点是数组或者为空</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前子节点是文本，则把它清空</span></span><br><span class="line">        hostSetElementText(container, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新的子节点是数组，则挂载新子节点</span></span><br><span class="line">        mountChildren(</span><br><span class="line">          c2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对于一个元素的子节点 vnode 可能有三种情况：纯文本、vnode 数据 和 空。所以排列组合更新的时候就有 9 种情况</strong></p>
<ol>
<li><p>首先来看一下旧子节点是纯文本的情况：</p>
<ul>
<li><p>如果新子节点也是纯文本，那么做简单地文本替换即可；</p>
</li>
<li><p>如果新子节点是空，那么删除旧子节点即可；</p>
</li>
<li><p>如果新子节点是 vnode 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。</p>
</li>
</ul>
</li>
<li><p>接下来看一下旧子节点是空的情况：</p>
<ul>
<li><p>如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可；</p>
</li>
<li><p>如果新子节点也是空，那么什么都不需要做；</p>
</li>
<li><p>如果新子节点是 vnode 数组，那么直接去旧子节点的父容器下添加多个新子节点即可。</p>
</li>
</ul>
</li>
<li><p>最后来看一下旧子节点是 vnode 数组的情况：</p>
<ul>
<li><p>如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点；</p>
</li>
<li><p>如果新子节点是空，那么删除旧子节点即可；</p>
</li>
<li><p>如果新子节点也是 vnode 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了核心 diff 算法。</p>
</li>
</ul>
</li>
</ol>
<h2 id="组件更新：完整的-DOM-diff-流程是怎样的？（下）"><a href="#组件更新：完整的-DOM-diff-流程是怎样的？（下）" class="headerlink" title="组件更新：完整的 DOM diff 流程是怎样的？（下）"></a>组件更新：完整的 DOM diff 流程是怎样的？（下）</h2><p>在 <code>processElement</code> 中，处理子节点的时候，当前后都是节点数组的时候，就执行核心的 <code>diff</code> 算法</p>
<p>新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心 diff 算法，就是在已知旧子节点 DOM 结构，vnode 和新子节点 vnode 情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作</p>
<h3 id="同步头部节点"><a href="#同步头部节点" class="headerlink" title="同步头部节点"></a>同步头部节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[i];</span><br><span class="line">    <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      <span class="comment">// 相同的节点，递归执行 patch 更新节点</span></span><br><span class="line">      patch(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        parentAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在整个 diff 的过程，我们需要维护几个变量：头部索引 <code>i</code>，旧子节点的尾部索引 <code>e1</code> 和新子节点的尾部索引 <code>e2</code></p>
<p>同步头部节点就是从头部开始，依次对比新节点和旧节点，如果他们相同则执行 patch 更新节点，如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束</p>
<h3 id="同步尾部节点"><a href="#同步尾部节点" class="headerlink" title="同步尾部节点"></a>同步尾部节点</h3><p>接着从尾部开始同步尾部节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[e2];</span><br><span class="line">    <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      patch(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        parentAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e1--;</span><br><span class="line">    e2--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点，如果不同或者索引 i 大于 e1 或者 e2 则同步过程结束</p>
<p>接下来有三种情况需要处理：</p>
<ul>
<li>新子节点剩余要添加的新节点</li>
<li>旧子节点剩余要删除的多余节点</li>
<li>未知子序列</li>
</ul>
<h3 id="添加新节点"><a href="#添加新节点" class="headerlink" title="添加新节点"></a>添加新节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="comment">// 3. 挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="comment">// 挂载新节点</span></span><br><span class="line">        patch(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          c2[i],</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        );</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果索引 i 大于尾部索引 e1 且小于 e2，那么从索引 i 开始到索引 e2 之间，我们直接挂载子树这部分的节点</p>
<h3 id="删除多余节点"><a href="#删除多余节点" class="headerlink" title="删除多余节点"></a>删除多余节点</h3><p>如果不满足添加新节点的情况，我们就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c d e</span></span><br><span class="line">  <span class="comment">// (a b) d e</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="comment">// 不满足</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      unmount(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果索引 i 大于尾部索引 e2，那么从索引 i 开始到索引 e1 之间，我们直接删除旧子树这部分的节点</p>
<h3 id="处理未知子序列"><a href="#处理未知子序列" class="headerlink" title="处理未知子序列"></a>处理未知子序列</h3><p>单纯的添加和删除节点都是比较理想的情况，操作起来也很容易，但是有些时候并非这么幸运，我们会遇到比较复杂的未知子序列</p>
<p>当我们完成前后的移动后，得到中间的两个子序列，记录开始位置 s1 s2</p>
<h4 id="根据-key-建立新子序列的索引图"><a href="#根据-key-建立新子序列的索引图" class="headerlink" title="根据 key 建立新子序列的索引图"></a>根据 key 建立新子序列的索引图</h4><p>通常我们在开发过程中， 会给 v-for 生成的列表中的每一项分配唯一 key 作为项的唯一的 ID，这个 key 在 diff 过程中起到很关键的作用。对于新旧子序列中的节点，我们认为 key 相同就是同一个节点，直接执行 patch 即可</p>
<p>根据 key 建立新子序列的索引图</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i; <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图 Map&lt;key, index&gt;</span></span><br><span class="line">  <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[i];</span><br><span class="line">    keyToNewIndexMap.set(nextChild.key, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="更新和移除旧节点"><a href="#更新和移除旧节点" class="headerlink" title="更新和移除旧节点"></a>更新和移除旧节点</h4><p>接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出需要移动的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点，不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i;</span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 新子序列已更新节点的数量</span></span><br><span class="line">  <span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 新子序列待更新节点的数量，等于新子序列的长度</span></span><br><span class="line">  <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 是否存在要移动的节点</span></span><br><span class="line">  <span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 用于跟踪判断是否有节点移动</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="built_in">Array</span>(toBePatched);</span><br><span class="line">  <span class="comment">// 初始化数组，每个元素的值都是 0</span></span><br><span class="line">  <span class="comment">// 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 正序遍历旧子序列</span></span><br><span class="line">  <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">    <span class="comment">// 拿到每一个旧子序列节点</span></span><br><span class="line">    <span class="keyword">const</span> prevChild = c1[i];</span><br><span class="line">    <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">      <span class="comment">// 所有新的子序列节点都已经更新，剩余的节点删除</span></span><br><span class="line">      unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找旧子序列中的节点在新子序列中的索引</span></span><br><span class="line">    <span class="keyword">let</span> newIndex = keyToNewIndexMap.get(prevChild.key);</span><br><span class="line">    <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 找不到说明旧子序列已经不存在于新子序列中，则删除该节点</span></span><br><span class="line">      unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解</span></span><br><span class="line">      newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动</span></span><br><span class="line">      <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">        maxNewIndexSoFar = newIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moved = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新新旧子序列中匹配的节点</span></span><br><span class="line">      patch(</span><br><span class="line">        prevChild,</span><br><span class="line">        c2[newIndex],</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      patched++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移动和挂载新节点"><a href="#移动和挂载新节点" class="headerlink" title="移动和挂载新节点"></a>移动和挂载新节点</h4><p>最后我们就要移动和挂载新节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g</span></span><br><span class="line">  <span class="comment">// (a b) e c d h f g</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i; <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 5.3 移动和挂载新节点</span></span><br><span class="line">  <span class="comment">// 仅当节点移动时生成最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">    ? getSequence(newIndexToOldIndexMap)</span><br><span class="line">    : EMPTY_ARR;</span><br><span class="line">  <span class="keyword">let</span> j = increasingNewIndexSequence.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 倒序遍历以便我们可以使用最后更新的节点作为锚点</span></span><br><span class="line">  <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">    <span class="comment">// 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].el : parentAnchor;</span><br><span class="line">    <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 挂载新的子节点</span></span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        nextChild,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="comment">// 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">        move(nextChild, container, anchor, <span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序递增子序列</span></span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue.js 的更新粒度是组件级别的，并且 Vue.js 在 patch 某个组件的时候，如果遇到组件这类抽象节点，在某些条件下也会触发子组件的更新。</p>
<p>对于普通元素节点的更新，主要是更新一些属性，以及它的子节点。子节点的更新又分为多种情况，其中最复杂的情况为数组到数组的更新，内部又根据不同情况分成几个流程去 diff，遇到需要移动的情况还要去求解子节点的最长递增子序列。</p>
<p>整个更新过程还是利用了树的深度遍历，递归执行 patch 方法，最终完成了整个组件树的更新。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/blog/tags/vue3/" rel="tag"># vue3</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2020/08/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/" rel="prev" title="前端工程化实践笔记">
                  <i class="fa fa-chevron-left"></i> 前端工程化实践笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2020/08/20/vue3%E4%B9%8BCompositionAPI%E7%9B%B8%E5%85%B3/" rel="next" title="vue3之CompositionAPI相关">
                  vue3之CompositionAPI相关 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NDkyOC8yMTQ1MA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div><div class="footer-custom">
</div>


    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.0/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.0/source/js/motion.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.0/source/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.0/source/js/local-search.js"></script>










<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


  








    <div class="pjax">
  

  

  

<script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "2020/08/20/vue3组件核心源码阅读笔记/"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
</body>
</html>
