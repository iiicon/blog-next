<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>之哥的荣耀</title>
  
  <subtitle>不满是向上的车轮，能够载不自满的人类，向人道前进</subtitle>
  <link href="https://iiicon.github.io/blog-next/atom.xml" rel="self"/>
  
  <link href="https://iiicon.github.io/blog-next/"/>
  <updated>2021-12-21T06:04:02.281Z</updated>
  <id>https://iiicon.github.io/blog-next/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js最长递增子序列</title>
    <link href="https://iiicon.github.io/blog-next/2020/10/12/js%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://iiicon.github.io/blog-next/2020/10/12/js%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-10-12T12:04:50.000Z</published>
    <updated>2021-12-21T06:04:02.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3-DOM-diff-最长递增子序列的实现"><a href="#vue3-DOM-diff-最长递增子序列的实现" class="headerlink" title="vue3 DOM diff 最长递增子序列的实现"></a>vue3 DOM diff 最长递增子序列的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSequence</span>(<span class="params">arr: number[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 数组副本</span></span><br><span class="line">  <span class="keyword">const</span> p = arr.slice();</span><br><span class="line">  <span class="comment">// 最后返回的序列 存储的是长度为 i 的递增子序列最小末尾值的索引</span></span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 保存数组第 i 项</span></span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 取出现有的列表最后一个值</span></span><br><span class="line">      j = result[result.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果第 i-1 项小于第 i 项，就要把下标 i 排列到 result 的最后，继续下一个循环</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        p[i] = j;</span><br><span class="line">        result.push(i);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则就要挨个和前面的比较</span></span><br><span class="line">      u = <span class="number">0</span>; <span class="comment">// 索引（放置的索引）</span></span><br><span class="line">      <span class="comment">// 保存现有 result 的长度</span></span><br><span class="line">      v = result.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 利用二分查找出比 第 i 项小的值(最小差，也就是最接近) c，并把 result 的长度设为 c</span></span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = ((u + v) / <span class="number">2</span>) | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到 位置 u 更新 result[u]</span></span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  u = result.length;</span><br><span class="line">  v = result[u - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回溯数组 p，找到最终的索引</span></span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result[u] = v;</span><br><span class="line">    v = p[v];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-300-最长上升子序列"><a href="#leetcode-300-最长上升子序列" class="headerlink" title="leetcode 300 最长上升子序列"></a>leetcode 300 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>vue3 对应的是 O(nlogn) 的复杂度，下面写 O(n^2) 的复杂度<br>思路就是双层循环，动态规划<br>比如数组的第 i 项对应的最长子序列 就是 第 i - 1 项对应的最长子序列 + 1<br>[9,8,3,4,5] 的子序列长度数组就是 [1,1,1,2,3]</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLTS = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3-DOM-diff-最长递增子序列的实现&quot;&gt;&lt;a href=&quot;#vue3-DOM-diff-最长递增子序列的实现&quot; class=&quot;headerlink&quot; title=&quot;vue3 DOM diff 最长递增子序列的实现&quot;&gt;&lt;/a&gt;vue3 DOM diff </summary>
      
    
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/categories/js/"/>
    
    
    <category term="code" scheme="https://iiicon.github.io/blog-next/tags/code/"/>
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/tags/vue/"/>
    
    <category term="算法" scheme="https://iiicon.github.io/blog-next/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://iiicon.github.io/blog-next/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>nodejs基础</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/27/nodejs%E4%BB%8B%E7%BB%8D/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/27/nodejs%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-09-27T09:22:18.000Z</published>
    <updated>2021-12-21T06:04:02.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Node.js 是一个 Javscript 运行环境(runtime)。它让 JavScript 可以开发后端程序，<br>它几乎能实现其他后端语言能实现的所有功能。</p><p>Nodejs 是基于 Gogle V8 引擎，V8 引擎是 Gogle 发布的一款开源的 JavScript 引擎，<br>原来主要用于 Chrome 浏览器的 JS 解释部分，但是 Ryan Dahl 这哥们，鬼才般的，把这个 V8<br>引擎搬到了服务器上，用于做服务器的软件。</p><a id="more"></a><h2 id="nodejs-一些优势"><a href="#nodejs-一些优势" class="headerlink" title="nodejs 一些优势"></a>nodejs 一些优势</h2><ol><li>Nodejs 用户量大</li><li>Nodejs 是程序员必备技能</li><li>Nodejs 最擅长高并发</li><li>Nodejs 简单</li><li>Nodejs 可实现的功能多：Nodejs 不仅可以像其他后端语言一样写动态网站、写接口，<br>还可以应用在云计算平台、游戏开发、区块链开发、即时通讯、跨平台 Ap 开发、桌面应用<br>开发（elctron）、云直播、物联网领域等</li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>一类是 Node 提供的模块，称为核心模块，另一类是用户编写的模块，称为文件模块</p><p>遵照 commonJS 规范, module.exports 导出默认对象，exports.xx 导出对象 {xx}</p><p>nodejs 的第三方模块由包组成，用包来管理有依赖关系的一些模块</p><p>包目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package.json :包描述文件。</span><br><span class="line">bin :用于存放可执行二进制文件的目录。</span><br><span class="line">lib :用于存放 JavScript 代码的目录。</span><br><span class="line">doc :用于存放文档的目录。</span><br></pre></td></tr></table></figure><ul><li>http</li><li>url</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>dependence</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Node.js 是一个 Javscript 运行环境(runtime)。它让 JavScript 可以开发后端程序，&lt;br&gt;它几乎能实现其他后端语言能实现的所有功能。&lt;/p&gt;
&lt;p&gt;Nodejs 是基于 Gogle V8 引擎，V8 引擎是 Gogle 发布的一款开源的 JavScript 引擎，&lt;br&gt;原来主要用于 Chrome 浏览器的 JS 解释部分，但是 Ryan Dahl 这哥们，鬼才般的，把这个 V8&lt;br&gt;引擎搬到了服务器上，用于做服务器的软件。&lt;/p&gt;</summary>
    
    
    
    <category term="nodejs" scheme="https://iiicon.github.io/blog-next/categories/nodejs/"/>
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/tags/js/"/>
    
    <category term="node" scheme="https://iiicon.github.io/blog-next/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>如何成为公司独当一面的工程师（转）</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/27/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%85%AC%E5%8F%B8%E7%8B%AC%E5%BD%93%E4%B8%80%E9%9D%A2%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/27/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%85%AC%E5%8F%B8%E7%8B%AC%E5%BD%93%E4%B8%80%E9%9D%A2%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88/</id>
    <published>2020-09-27T01:40:45.000Z</published>
    <updated>2021-12-21T06:04:02.354Z</updated>
    
    <content type="html"><![CDATA[<p>下面的文章引入自黄轶老师的公众号，我们很多时候都会发现自己对于技术处于不是特别良好的状态，或满足，或迷茫，或焦虑，或踌躇不前，我希望这篇文章能够让我在舒适圈的时候提醒自己，也能经常回头看自己对标以下之能力有没有提高</p><blockquote><p>如今的互联网市场对高阶技术岗位的需求越来越多，成为独当一面的工程师已经成为很多一二线互联网公司招聘的标准门槛了。那么如何成长为独当一面的工程师呢，我会从技术能力和业务能力 2 个方面去阐述。</p></blockquote><h2 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h2><p>技术能力无疑是衡量一个工程师水平最重要的依据，那么对于独当一面的工程师技术能力的要求是怎样的呢。</p><h3 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h3><p>职业技能就是工作中依赖的技术栈，下面我们以前端工程师为例，看一下有需要掌握哪些职业技能。</p><h4 id="熟练掌握-HTML、CSS、JavaScript"><a href="#熟练掌握-HTML、CSS、JavaScript" class="headerlink" title="熟练掌握 HTML、CSS、JavaScript"></a>熟练掌握 HTML、CSS、JavaScript</h4><p>用语义化的 HTML 标签配合 CSS 百分百还原设计稿，并使用 JavaScript 完成各种交互逻辑。这是前端的基本功，除了通过书籍、视频等渠道学习之外，你可以通过做大量业务，不断写代码去应用所学知识，不断积累。</p><h4 id="熟练掌握一门-MVVM-框架"><a href="#熟练掌握一门-MVVM-框架" class="headerlink" title="熟练掌握一门 MVVM 框架"></a>熟练掌握一门 MVVM 框架</h4><p>Vue、React、Angular 其一，随着前端的日益复杂，大部分场景都离不开它们。你需要清楚的了解框架出现的意义，框架的职责边界，你能轻松应用框架提供的各种能力辅助开发工作。除了不断在工作中应用，你还可以主动去学习框架源码，了解框架的实现原理。</p><h4 id="至少要学会一种打包工具"><a href="#至少要学会一种打包工具" class="headerlink" title="至少要学会一种打包工具"></a>至少要学会一种打包工具</h4><p>以 webpack 为例，你需要熟练掌握 webpack 的配置，学会利用 webpack 辅助我们的开发、部署和优化。你可以尝试去编写 webpack 的 loader 和 plugin。例如我们平时开发工作中需要 mock 数据，那么我们可以编写一个 webpack 插件，在不改源码的情况下，实现在开发环境请求 mock 接口，测试环境请求线上接口。</p><h4 id="熟练掌握前端的一些广度知识"><a href="#熟练掌握前端的一些广度知识" class="headerlink" title="熟练掌握前端的一些广度知识"></a>熟练掌握前端的一些广度知识</h4><p>例如HTTP、Web 安全、性能优化、数据结构和算法等。除了通过书籍、视频等渠道学习之外，你可以在平时工作中不断去应用和验证。例如性能优化，你可以去分析页面的性能瓶颈，在前端还是后端？如果是在前端，你还可以进一步分析白屏时间、首屏渲染时间、JS 加载时间、JS 执行时间等等，最后通过统计的手段做性能监控和报警。</p><h3 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h3><p>开发效率的高低，直接决定你的工作产出比，那么如何提升开发效率呢。</p><h4 id="给自己设一个免打扰时间"><a href="#给自己设一个免打扰时间" class="headerlink" title="给自己设一个免打扰时间"></a>给自己设一个免打扰时间</h4><p>例如下午的 2点-4点，这个时间专心 coding，不看微信不刷微博不开会，这样的编码会很高效。</p><h4 id="工作中善于提炼可复用的代码和逻辑"><a href="#工作中善于提炼可复用的代码和逻辑" class="headerlink" title="工作中善于提炼可复用的代码和逻辑"></a>工作中善于提炼可复用的代码和逻辑</h4><p>例如当你在开发过程中发现某组件在其它项目中实现过，这个时候千万不要想着去 CV 代码，而是把它抽象成可复用的业务组件，对外设计好输入和输出接口，并抽取到专门的仓库中管理，业务通过 npm 私服的方式去引入。</p><h4 id="善于通过技术的手段去提升效率"><a href="#善于通过技术的手段去提升效率" class="headerlink" title="善于通过技术的手段去提升效率"></a>善于通过技术的手段去提升效率</h4><p>例如当你去开发和维护多个项目的时候，每个项目都包含一些类似的代码和配置，你就可以想着去开发一个脚手架，自动帮助你去初始化项目代码和一些配置文件。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>每个工程师都会在工作中遇到各种问题，解决问题的能力侧面反映了一个人的技术能力。</p><h4 id="线上问题-case-study"><a href="#线上问题-case-study" class="headerlink" title="线上问题 case study"></a>线上问题 case study</h4><p>当遇到线上问题，你可以配合一些报错日志快速定位问题出，找到快速修复的方案，并且在每次出线上问题后都认真的做 case study，找出引发问题的多方面原因，并给出对应的解决方案，避免日后再出现类似问题。</p><h4 id="探究问题的本质"><a href="#探究问题的本质" class="headerlink" title="探究问题的本质"></a>探究问题的本质</h4><p>在开发过程中遇到报错，你可以通过代码执行堆栈和报错信息找到引起错误的根本原因，从而找到最合理的修复方案，如果报错的源头是第三方插件，你应该趁机去了解第三方实现的原理。</p><h3 id="学会提问"><a href="#学会提问" class="headerlink" title="学会提问"></a>学会提问</h3><p>并不是所有问题都要自己独立解决，有些时候也可以求助于他人，好的提问方式非常重要。例如你在提问之前，自己应该经过充分的思考，并学会把问题拆解，在拆解的过程中就会把问题的复杂度降低。要善用搜索引擎，把关键字提取出来去搜索引擎上去搜索，先尝试自己去解决问题。如果仍然不能解决，可以将问题的相关上下文、截图及必要标识及自己的思考过程、查找到的相关资料，以及自己的分析发送给想要帮助你的人，并能提供最小化复现的问题。</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>曾经有个大佬跟我说过，如果每半年去回顾你之前写的代码，都会觉得像坨屎的话，那说明你在进步。</p><h4 id="不要过度设计"><a href="#不要过度设计" class="headerlink" title="不要过度设计"></a>不要过度设计</h4><p>有些人喜欢一次性把代码写好，预留各种扩展接口，过度设计，但由于需求的的变化往往不可预测，非常容易导致花了大量的时间却写了大量无用的代码，产出低下。在高速发展的互联网公司是绝对不能容忍这种情况的，而应该是敏捷开发，快速迭代。</p><h4 id="及时重构"><a href="#及时重构" class="headerlink" title="及时重构"></a>及时重构</h4><p>通常我们为了一个项目快速上线，第一版的代码可能会有很多问题，当我们在基于之前版本的代码开发新功能的时候，如果遇到之前代码实现不合理的地方要及时重构，而不要敷衍了事，如果等到代码量已经很大的时候去重构，会非常困难和痛苦，并且还可能有 regression 风险。</p><h4 id="codereview"><a href="#codereview" class="headerlink" title="codereview"></a>codereview</h4><p>找比自己厉害的同事帮助自己的代码做 codereview，吸取他们的一些好的建议，也可以去 review 其他同事的代码，觉得写的好的代码要学习，觉得写的不好的地方可以  ”挑刺“，引起讨论，追寻最佳实践。并且一个团队要制定统一的代码规范和风格。</p><h4 id="学习优秀源码"><a href="#学习优秀源码" class="headerlink" title="学习优秀源码"></a>学习优秀源码</h4><p>如何去写出优秀的代码，首先要学会模仿，你应该经常去 GitHub 去阅读一些优秀的源码，把好的编程思想和代码实现借鉴到自己的工作项目中。</p><h3 id="技术沉淀"><a href="#技术沉淀" class="headerlink" title="技术沉淀"></a>技术沉淀</h3><p>技术是一个长期学习并积累的过程，需要经常做一些技术沉淀。</p><h3 id="技术分享"><a href="#技术分享" class="headerlink" title="技术分享"></a>技术分享</h3><p>把工作中遇到的一些问题的解决方案、学习的一些新技术，产出的一些技术项目总结下来，作为对内或者对外（公司允许的话）技术分享和输出。对内分享的话可以让大家能知道你做的东西，并活跃内部技术氛围，锻炼表述能力，这个能力在大公司的晋升述职中非常重要；对外分享可以锻炼写作能力，提升个人或者是团队的技术影响力。</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>如果在工作中做的不错的项目，有开源价值并且公司允许的前提下，可以考虑开源，因为开源会让你对项目质量有更高的追求。例如之前我在滴滴做的 cube-ui，开源会让我们对代码的质量要求更高，并补充了完整的文档、示例和测试。而且随着越来越多人使用，用户帮我们反馈了很多 bug，也补充了很多功能，直接帮助我们省了 QA 的人力。好的开源项目也可以帮助我们提升个人和团队的技术影响力。</p><h3 id="快速学习"><a href="#快速学习" class="headerlink" title="快速学习"></a>快速学习</h3><p>技术变化日新月异，快速学习的能力尤其重要。</p><h4 id="阅读官方文档"><a href="#阅读官方文档" class="headerlink" title="阅读官方文档"></a>阅读官方文档</h4><p>当你去学习一门新技术的时候首先应该去阅读官方文档，而不要去看社区总结的文章，因为官方文档是最权威的，并且是实时更新的，而他人总结的二手资料很可能是过时甚至是有误的。</p><h4 id="在工作中实践"><a href="#在工作中实践" class="headerlink" title="在工作中实践"></a>在工作中实践</h4><p>学习如果脱离工作的实践，其实是非常低效的。你应该把自己所学的知识并在工作中反复实践和验证，及时反馈，加深学习的印象。不要花时间去学习与工作无太多直接关系的领域。</p><h4 id="先精通一门技术"><a href="#先精通一门技术" class="headerlink" title="先精通一门技术"></a>先精通一门技术</h4><p>不同的技术之间其实是融会贯通的，当你对一个技术精通并总结出方法论以后，很容易上手别的技术。比如一个对  Vue 精通的同学，上手 React 必定毫无难度，对 Web 前端开发精通的同学开发小程序也是毫无压力。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型是大部分工程师都会面临的问题，好的工程师一定要有好的技术选型的能力。</p><h4 id="技术选型的标准"><a href="#技术选型的标准" class="headerlink" title="技术选型的标准"></a>技术选型的标准</h4><p>当你去选择某个开源项目的时候，应该参考以下几个方面：feature 完整度（能否很好满足我们的需求），使用量（npm 下载量、是否有大公司使用），维护力度（最近更新时间、更新频率、issue 和 pr 的处理情况），测试（是否有测试，测试覆盖率），文档（文档和示例是否完善），维护者（团队、个人的技术能力以及他们的技术影响力），流行度（star、fork 量)。</p><h3 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h3><p>当现有轮子不能满足我们的需求的时候，我们要有自己造轮子的能力。</p><h4 id="学会造轮子"><a href="#学会造轮子" class="headerlink" title="学会造轮子"></a>学会造轮子</h4><p>你需要经常去学习和研究其它的轮子是如何造的，学的多了，自然就掌握了造轮子的一些规律和方法论，了解轮子实现的本质原理，也就可以根据自己的需求和场景去定制化轮子了，并且你的轮子也可以是其它小轮子组装而成。例如我在滴滴的时候为了实现一个媲美原生 iOS 体验的 Picker 组件，先是研究了 isroll 的实现，在它基础上扩展实现了 better-scroll，然后在 better-scroll 的基础上扩展出 Picker 组件。</p><h2 id="业务能力"><a href="#业务能力" class="headerlink" title="业务能力"></a>业务能力</h2><p>作为独当一面的工程师，除了过硬的技术能力，也需要有良好的业务能力。</p><h3 id="owner-意识"><a href="#owner-意识" class="headerlink" title="owner 意识"></a>owner 意识</h3><p>如果你不甘心只当一颗螺丝钉，你需要有 owner 意识，对产品和项目负责。例如我现在在 zoom，从需求、设计、开发、测试到最终的上线都是由工程师在主导，并协调各个角色成员。这对工程师提出了更高的要求，也锻炼了工程师的综合素质能力。即使你所在的公司项目并不由工程师主导，你也可以以这个标准来要求自己。</p><h3 id="产品思维"><a href="#产品思维" class="headerlink" title="产品思维"></a>产品思维</h3><p>当你接到一个需求的时候，也要思考这个需求解决了什么问题，有什么价值和意义。作为一个工程师，最好能参与到需求早期的讨论中，充分理解业务，这样你对需求的把握和理解会更准确，而不是产品说什么你就做什么，有些时候你会找到一条既能满足需求又能节约开发成本的路。</p><h3 id="沟通能力"><a href="#沟通能力" class="headerlink" title="沟通能力"></a>沟通能力</h3><p>很多人希望做一个只写代码的美男（女）子，但实际情况你需要和不同的工作岗位的人沟通。沟通能力是非常重要的，很多时候你需要去了解你的需求方的想法，并输出你的想法。如果你两耳不闻窗外事，很可能做出来的东西并不是他人想要的，充分的沟通可以避免走一些弯路，提升工作效率。</p><h3 id="敬畏上线"><a href="#敬畏上线" class="headerlink" title="敬畏上线"></a>敬畏上线</h3><p>很多没有在大公司待过的人对于上线的视程度不够，一旦上线出问题，第一反应并不是回滚代码，而是去定位问题，通过下一次上线修复。这个行为在大公司是绝对不允许的，因为当你用户量大了，每一次上线事故的影响面都会很大，如果不及时回滚，对公司也会造成非常大的损失。因此要对上线有敬畏心，保证整个上线过程是自动化而非人工参与（因为人是不靠谱的），上线过程中需要观察监控，一旦有任何数据异常要及时回滚，然后再定位问题重新上线，最好避免高峰期上线。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通篇讲了很多方法，但实际上在你进阶成为独当一面工程师的路上，这些方法也只是仅供参考，真正能成为大牛的人，能够直面困难和挫折，敢于跳出自己的舒适区追求进步，能熬得住突破瓶颈长时间的寂寞，是肯下笨功夫的聪明人。没有什么人可以靠着看一两篇文章就能成为大牛，而真正重要的，是多年如一日的坚持。</p><p>与大家共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面的文章引入自黄轶老师的公众号，我们很多时候都会发现自己对于技术处于不是特别良好的状态，或满足，或迷茫，或焦虑，或踌躇不前，我希望这篇文章能够让我在舒适圈的时候提醒自己，也能经常回头看自己对标以下之能力有没有提高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如今的互联网市场对</summary>
      
    
    
    
    <category term="综合" scheme="https://iiicon.github.io/blog-next/categories/%E7%BB%BC%E5%90%88/"/>
    
    
    <category term="essay" scheme="https://iiicon.github.io/blog-next/tags/essay/"/>
    
    <category term="前端" scheme="https://iiicon.github.io/blog-next/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《重构》读书笔记</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/26/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/26/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T15:33:16.000Z</published>
    <updated>2021-12-21T06:04:02.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重构，第一个实例"><a href="#重构，第一个实例" class="headerlink" title="重构，第一个实例"></a>重构，第一个实例</h2><blockquote><p>是需求的变化使重构变得必要。如果一段代码能正常工作，并且他不会再被修改，那么完全可以不去重构它。能改进之当然很好，但若没人需要去理解它，它就不会真正妨碍什么。如果确实有人需要理解它的工作原理，并且理解起来很费劲，那你就需要改进一下代码了。<br>要将我的理解转化到代码里，得先将这块代码抽取成一个独立的函数，按它所干的事情给它命名，每次想将一块代码抽取成一个函数时，我都会遵循一个标准流程，最大程度减少犯错的可能，这个流程命名为提炼函数。</p></blockquote><ul><li>分解 statement 函数</li><li>移除 play 临时变量，以查询取代</li><li>提炼计算观众量积分的逻辑</li><li>移除 format 变量 (将函数赋值为临时变量，改为一个明确的函数)</li><li>移除观众量积分总和 (提炼函数和应用内联变量) -&gt; 这两部称为以查询取代临时变量？</li><li>拆分计算阶段和格式化阶段</li><li>分离为两个文件（两个阶段）</li><li>按类型重组计算过程，使用多态计算器来提供数据</li></ul><h2 id="重构的原则"><a href="#重构的原则" class="headerlink" title="重构的原则"></a>重构的原则</h2><h3 id="何谓重构"><a href="#何谓重构" class="headerlink" title="何谓重构"></a>何谓重构</h3><p>使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。它和性能优化不同，重构是为了让代码更容易理解，更易于修改，这可能使程序运行得更快，也可能使程序运行得更慢</p><h3 id="两顶帽子"><a href="#两顶帽子" class="headerlink" title="两顶帽子"></a>两顶帽子</h3><p>两顶帽子指添加新功能和重构，软件开发过程中经常变换帽子，但是无论何时都清楚自己戴的哪一顶帽子，并且明白不同的帽子对编程状态提出的不同要求</p><h3 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h3><ul><li>重构改进软件的设计</li><li>重构使软件更容易理解</li><li>重构帮助找到 bug</li><li>重构提高编程速度</li></ul><h3 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h3><p>第三次做类似的事情，你就应该重构</p><ul><li>预备性重构：让添加新功能更容易</li><li>帮助理解的重构： 使代码更易懂</li><li>捡垃圾式重构（先记下来）</li><li>有计划重构和见机行事的重构</li></ul><h4 id="长期重构"><a href="#长期重构" class="headerlink" title="长期重构"></a>长期重构</h4><p>可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略</p><h4 id="复审代码时重构"><a href="#复审代码时重构" class="headerlink" title="复审代码时重构"></a>复审代码时重构</h4><p>与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审</p><h4 id="怎么对经理说"><a href="#怎么对经理说" class="headerlink" title="怎么对经理说"></a>怎么对经理说</h4><p>不要告诉经理！</p><h3 id="重构的挑战"><a href="#重构的挑战" class="headerlink" title="重构的挑战"></a>重构的挑战</h3><h4 id="延缓新功能开发"><a href="#延缓新功能开发" class="headerlink" title="延缓新功能开发"></a>延缓新功能开发</h4><p>重构的唯一目的就是让我们开发更快，用更少的<br>工作量创造更大的价值。</p><p>有些人试图用“整洁的代码”“良好的工程实践”之类<br>道德理由来论证重构的必要性，我认为这是个陷阱。重构的<br>意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出<br>发的考量。我们之所以重构，因为它能让我们更快——添加<br>功能更快，修复 bug 更快。<br>一定要随时记住这一点，与别人<br>交流时也要不断强调这一点。重构应该总是由经济利益驱<br>动。程序员、经理和客户越理解这一点，<br>“好的设计”那条<br>曲线就会越经常出现。</p><h4 id="代码所有权"><a href="#代码所有权" class="headerlink" title="代码所有权"></a>代码所有权</h4><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h4 id="遗留代码"><a href="#遗留代码" class="headerlink" title="遗留代码"></a>遗留代码</h4><h3 id="重构、架构和-YAGNI"><a href="#重构、架构和-YAGNI" class="headerlink" title="重构、架构和 YAGNI"></a>重构、架构和 YAGNI</h3><h3 id="重构与软件开发过程"><a href="#重构与软件开发过程" class="headerlink" title="重构与软件开发过程"></a>重构与软件开发过程</h3><h3 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h3><h3 id="重构起源何处"><a href="#重构起源何处" class="headerlink" title="重构起源何处"></a>重构起源何处</h3><h3 id="自动化重构"><a href="#自动化重构" class="headerlink" title="自动化重构"></a>自动化重构</h3><p>IDE</p><h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><blockquote><p>你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。</p></blockquote><h3 id="神秘命名-Mysterious-Name"><a href="#神秘命名-Mysterious-Name" class="headerlink" title="神秘命名 Mysterious Name"></a>神秘命名 Mysterious Name</h3><p>整洁代码最重要的一环就是好的名字</p><p>为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。</p><h3 id="重复代码-Duplicated-Code"><a href="#重复代码-Duplicated-Code" class="headerlink" title="重复代码 Duplicated Code"></a>重复代码 Duplicated Code</h3><p>最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数（106）提炼出重复的代码</p><p>如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用。</p><h3 id="过长函数-Long-Function"><a href="#过长函数-Long-Function" class="headerlink" title="过长函数 Long Function"></a>过长函数 Long Function</h3><p>你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</p><p>你可以经常运用以查询取代临时变量（178）来消除临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。</p><p>条件表达式和循环常常也是提炼的信号。</p><h3 id="过长的参数列表-Long-Parameter-List"><a href="#过长的参数列表-Long-Parameter-List" class="headerlink" title="过长的参数列表 Long Parameter List"></a>过长的参数列表 Long Parameter List</h3><p>如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）<br>如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法<br>如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象<br>如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）<br>使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组<br>合成类（144），将这些共同的参数变成这个类的字段</p><h3 id="全局数据-Global-Data"><a href="#全局数据-Global-Data" class="headerlink" title="全局数据 Global Data"></a>全局数据 Global Data</h3><h3 id="可变数据-Mutable-Data"><a href="#可变数据-Mutable-Data" class="headerlink" title="可变数据 Mutable Data"></a>可变数据 Mutable Data</h3><p>对数据的修改经常导致出乎意料的结果和难以发现的 bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了</p><h3 id="发散式变化-Divergent-Change"><a href="#发散式变化-Divergent-Change" class="headerlink" title="发散式变化 Divergent Change"></a>发散式变化 Divergent Change</h3><p>如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了</p><h3 id="霰弹式修改-Shotgun-Surgery"><a href="#霰弹式修改-Shotgun-Surgery" class="headerlink" title="霰弹式修改 Shotgun Surgery"></a>霰弹式修改 Shotgun Surgery</h3><p>如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改</p><h3 id="依赖情节-Feature-Envy"><a href="#依赖情节-Feature-Envy" class="headerlink" title="依赖情节 Feature Envy"></a>依赖情节 Feature Envy</h3><p>一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况</p><h3 id="数据泥团-Data-Clumps"><a href="#数据泥团-Data-Clumps" class="headerlink" title="数据泥团 Data Clumps"></a>数据泥团 Data Clumps</h3><p>两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象</p><h3 id="基本类型偏执-Primitive-Obsession"><a href="#基本类型偏执-Primitive-Obsession" class="headerlink" title="基本类型偏执 Primitive Obsession"></a>基本类型偏执 Primitive Obsession</h3><p>很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似 if (a &lt; upper<br>&amp;&amp; a &gt; lower)这样的代码</p><h3 id="重复的-switch-Repeated-Switches"><a href="#重复的-switch-Repeated-Switches" class="headerlink" title="重复的 switch Repeated Switches"></a>重复的 switch Repeated Switches</h3><p>重复的 switch 的问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库</p><h3 id="循环语句-Loops"><a href="#循环语句-Loops" class="headerlink" title="循环语句 Loops"></a>循环语句 Loops</h3><p>用以管道取代循环（231）来让这些老古董退休。我们发现，管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作</p><h3 id="冗赘的元素-Lazy-Element"><a href="#冗赘的元素-Lazy-Element" class="headerlink" title="冗赘的元素 Lazy Element"></a>冗赘的元素 Lazy Element</h3><p>程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。</p><h3 id="夸夸其谈通用性-Speculative-Generality"><a href="#夸夸其谈通用性-Speculative-Generality" class="headerlink" title="夸夸其谈通用性 Speculative Generality"></a>夸夸其谈通用性 Speculative Generality</h3><p>当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了</p><h3 id="临时字段-Temporary-Field"><a href="#临时字段-Temporary-Field" class="headerlink" title="临时字段 Temporary Field"></a>临时字段 Temporary Field</h3><p>有时你会看到这样的类：其内部某个字段仅为某种特定情况而设，这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段</p><h3 id="过长的消息链-Message-Chains"><a href="#过长的消息链-Message-Chains" class="headerlink" title="过长的消息链 Message Chains"></a>过长的消息链 Message Chains</h3><p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。</p><h3 id="中间人-Middle-Man"><a href="#中间人-Middle-Man" class="headerlink" title="中间人  Middle Man"></a>中间人  Middle Man</h3><p>你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道</p><h3 id="内幕交易-Insider-trading"><a href="#内幕交易-Insider-trading" class="headerlink" title="内幕交易 Insider trading"></a>内幕交易 Insider trading</h3><p>软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来</p><h3 id="过大的类-Large-Class"><a href="#过大的类-Large-Class" class="headerlink" title="过大的类 Large Class"></a>过大的类 Large Class</h3><p>如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了</p><h3 id="异曲同工的类-Alternative-Class-with-Different-Interface"><a href="#异曲同工的类-Alternative-Class-with-Different-Interface" class="headerlink" title="异曲同工的类 Alternative Class with Different Interface"></a>异曲同工的类 Alternative Class with Different Interface</h3><p>使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类</p><h3 id="纯数据类-Data-Class"><a href="#纯数据类-Data-Class" class="headerlink" title="纯数据类 Data Class"></a>纯数据类 Data Class</h3><p>所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。这些类早期可能拥有public字段，若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）</p><p>纯数据类常常意味着行为被放在了错误的地方</p><h3 id="被拒绝的遗赠-Refused-Bequest"><a href="#被拒绝的遗赠-Refused-Bequest" class="headerlink" title="被拒绝的遗赠 Refused Bequest"></a>被拒绝的遗赠 Refused Bequest</h3><p>子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？</p><p>按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟</p><h3 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释 Comments"></a>注释 Comments</h3><p>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余</p><h2 id="构筑测试体系"><a href="#构筑测试体系" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重构，第一个实例&quot;&gt;&lt;a href=&quot;#重构，第一个实例&quot; class=&quot;headerlink&quot; title=&quot;重构，第一个实例&quot;&gt;&lt;/a&gt;重构，第一个实例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;是需求的变化使重构变得必要。如果一段代码能正常工作，并且他不会再被</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://iiicon.github.io/blog-next/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/tags/js/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法之汉诺塔问题和斐波那契数列</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/24/%E7%AE%97%E6%B3%95/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/24/%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-24T08:03:24.000Z</published>
    <updated>2021-12-21T06:04:02.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题通过思考逻辑"><a href="#算法题通过思考逻辑" class="headerlink" title="算法题通过思考逻辑"></a>算法题通过思考逻辑</h2><h3 id="普通人类思维"><a href="#普通人类思维" class="headerlink" title="普通人类思维"></a>普通人类思维</h3><ul><li>将人类的思维过程用严谨的语言表达出来，将其翻译成代码或伪代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">23</span>, <span class="number">99</span>, <span class="number">17</span>, <span class="number">28</span>, <span class="number">84</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &gt; result) &#123;</span><br><span class="line">      result = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">max(array); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure><h3 id="数学思维"><a href="#数学思维" class="headerlink" title="数学思维"></a>数学思维</h3><ul><li>利用数学知识</li><li>找到对应的数学公式</li><li>像解题一样解出来</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">23</span>, <span class="number">99</span>, <span class="number">17</span>, <span class="number">28</span>, <span class="number">84</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> otherMax = max(array.slice(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> array[<span class="number">0</span>] &gt; otherMax ? array[<span class="number">0</span>] : otherMax;</span><br><span class="line">&#125;</span><br><span class="line">max(array); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新语法</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">23</span>, <span class="number">99</span>, <span class="number">17</span>, <span class="number">28</span>, <span class="number">84</span>];</span><br><span class="line"><span class="keyword">const</span> maxOfTwo = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (a &gt; b ? a : b);</span><br><span class="line"><span class="keyword">const</span> max = <span class="function">(<span class="params">[first, ...others]</span>) =&gt;</span></span><br><span class="line">  others.length &lt; <span class="number">1</span> ? first : maxOfTwo(first, max(others));</span><br><span class="line">max(array); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure><h4 id="如何证明这个算法是对的？"><a href="#如何证明这个算法是对的？" class="headerlink" title="如何证明这个算法是对的？"></a>如何证明这个算法是对的？</h4><ul><li>首先证明公式是对的，然后证明代码和公式是等价的</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>数学方法更容易通过形式化证明保证代码的正确性</li><li>但数学方法效率不一定高（但可以优化）</li><li>数学方法往往不够直观，普通人并没有什么数学知识</li><li>一般不能对变量进行二次赋值，因为数学里没有</li></ul><p><strong>这两种方法没有绝对哪种比哪种好</strong></p><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>有三根杆子 A B C，A 杆上有 N 个圆盘，盘子由下到上依次变小，要求按照下列规则将所有圆盘移至 C 杆： 每次只能移动一个圆盘，大盘不能叠在小盘上面<br>问： 如何移动？最少要移动多少次？</p><p>人类思维：<br>先把 A 上面的 N-1 个移动到 B，然后把最大的移动到 C，最后把 B 上面的 N-1 移到 C。那怎么把 A 上面的 N-1 移到 B？把 B 上面的 N-1 移到 C?<br>先把 A 上面的 N-2 移到 C，然后把最大的移到 B，最后把 C 上面的 N-2 移到 B<br>发现想不通，换数学思维</p><p>数学思维：<br>把 A 顶部的盘移到 B，记为 AB<br>AB + AC 表示先 AB 然后 AC<br>h(n, A, B, C) 表示 n 个 盘在 A，想去 C，B 无用<br>h(1, A, B, C) = AC<br>h(2, A, B, C) = h(1, A, C, B) + AC + h(1, B, A, C)<br>h(2, A, B, C) = AB + AC + BC<br>h(3, A, B, C) = h(2, A, C, B) + AC + h(2, B, A, C)<br>h(n, A, B, C) = h(n-1, A, C, B) + AC + h(n-1, B, A, C)</p><p><strong>归纳：发现 n 的问题总可以化成两个 n-1 的问题</strong></p><p>公式：<br><img src="https://i.loli.net/2020/09/24/p3tMSGwvUDnKfhP.png" alt="微信图片_20200924180138.png" loading="lazy"></p><p>代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h = <span class="function">(<span class="params">n, <span class="keyword">from</span>, cache, to</span>) =&gt;</span></span><br><span class="line">  n === <span class="number">1</span></span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;to&#125;</span>`</span></span><br><span class="line">    : h(n - <span class="number">1</span>, <span class="keyword">from</span>, to, cache) +</span><br><span class="line">      <span class="string">&quot;,&quot;</span> +</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span><span class="subst">$&#123;to&#125;</span>`</span> +</span><br><span class="line">      h(n - <span class="number">1</span>, cache, <span class="keyword">from</span>, to);</span><br></pre></td></tr></table></figure><h2 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h2><p>数学思维：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> (n === <span class="number">0</span> ? <span class="number">0</span> : n === <span class="number">1</span> ? <span class="number">1</span> : f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>你可以通过记忆化来优化它，空间换时间</p><p>人类思路：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> array = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>] + array[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th>数学思路更注重形式（结构）</th><th>人类思维更注重过程（命令）</th></tr></thead><tbody><tr><td>更加优雅简单</td><td>更容易执行被理解</td></tr><tr><td>其实更容易优化</td><td>对人脑负担更重</td></tr><tr><td>投身于数学，有无限广阔的可能性</td><td>被人类的经验所局限</td></tr></tbody></table><p>但复杂度是守恒的：复杂度不会因为任何原因降低<br>你愿意吧复杂度放在人脑这边还是机器那边<br>实际上，我们可以结合两种思路，各取所长</p><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>大部分浏览器是在 10000-30000 之间，大部分调用栈是够用的，一旦不够用，程序只能中止了</p><p>如何减少压栈？</p><ul><li>不用递归<br>用循环代替递归</li><li>用尾递归+尾递归优化<br>用尾递归代替递归</li></ul><h3 id="循环代替递归"><a href="#循环代替递归" class="headerlink" title="循环代替递归"></a>循环代替递归</h3><p>原代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> (n === <span class="number">1</span> ? <span class="number">1</span> : f(n - <span class="number">1</span>) * n);</span><br></pre></td></tr></table></figure><p>新代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result = result * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代代替递归"><a href="#迭代代替递归" class="headerlink" title="迭代代替递归"></a>迭代代替递归</h3><p>分析上面循环,结果如下</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>result</td><td>1</td><td>2</td><td>6</td><td>24</td><td>120</td></tr></tbody></table><p>只有 i 和 result 在变，而且是一起变</p><p>写出循环迭代代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>,</span><br><span class="line">    result = <span class="number">1</span>,</span><br><span class="line">    nexti,</span><br><span class="line">    nextResult;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">    nexti = i + <span class="number">1</span>;</span><br><span class="line">    nextResult = nexti * result;</span><br><span class="line">    i = nexti;</span><br><span class="line">    result = nextResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尾递归迭代代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  iterate = <span class="function">(<span class="params">i, n, result</span>) =&gt;</span></span><br><span class="line">    i === n ? result : iterate(i + <span class="number">1</span>, n, result * (i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterate(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>递归需要压栈，而栈的长度有限</li><li>可以使用循环代替递归</li><li>可以使用迭代代替普通递归</li><li>迭代用循环实现，也可以用递归</li><li>迭代理论上不需要压栈，但实际上有</li><li>尾调用优化可以消除不必要的压栈</li><li>JS 没有完全普及尾调用优化</li></ul><h2 id="递归的缺点及优化"><a href="#递归的缺点及优化" class="headerlink" title="递归的缺点及优化"></a>递归的缺点及优化</h2><p>堆栈溢出和重复计算</p><p>使用记忆化消除重复计算</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">memorize = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> (first, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(first <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">      cache[first] = fn(first, ...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[first]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = memorize(</span><br><span class="line">  <span class="function"><span class="params">n</span> =&gt;</span></span><br><span class="line">    n === <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">    n === <span class="number">1</span> ? <span class="number">1</span> :</span><br><span class="line">      f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>算法的思路</p><ul><li>人类思路</li><li>数学思路</li></ul><p>递归</p><ul><li>先递进再归纳</li><li>stcak overflow</li><li>尾调用优化</li><li>循环很有用</li><li>记忆化很有用</li><li>迭代要理解（尾调用一般就是迭代）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法题通过思考逻辑&quot;&gt;&lt;a href=&quot;#算法题通过思考逻辑&quot; class=&quot;headerlink&quot; title=&quot;算法题通过思考逻辑&quot;&gt;&lt;/a&gt;算法题通过思考逻辑&lt;/h2&gt;&lt;h3 id=&quot;普通人类思维&quot;&gt;&lt;a href=&quot;#普通人类思维&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://iiicon.github.io/blog-next/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="G" scheme="https://iiicon.github.io/blog-next/tags/G/"/>
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/tags/js/"/>
    
    <category term="算法" scheme="https://iiicon.github.io/blog-next/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-24T07:16:01.000Z</published>
    <updated>2021-12-21T06:04:02.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构研究的是 <strong>数据 + 数据的逻辑结构 + API</strong>，但我们需要研究存储结构以加速 API</p><h2 id="逻辑结构举例"><a href="#逻辑结构举例" class="headerlink" title="逻辑结构举例"></a>逻辑结构举例</h2><ul><li><p>线性表 Linear List</p><ul><li>顺序存储的线性表叫数组</li><li>链接存储的线性表叫链表</li><li>链表又分为单向链表、双向链表、循环链表</li></ul></li><li><p>树形结构</p><ul><li>树 二叉树 二叉搜索树 红黑树 B 树 堆</li></ul></li><li><p>哈希结构</p></li><li><p>图</p></li><li><p>其他</p></li></ul><h2 id="存储结构举例"><a href="#存储结构举例" class="headerlink" title="存储结构举例"></a>存储结构举例</h2><ul><li><p>顺序存储</p><ul><li>用连续的内存存储</li><li>二叉树可以顺序存储</li></ul></li><li><p>链接存储</p><ul><li>用分散的内存存储，中间用地址来链接</li><li>链表 树都可以用这种方式存</li></ul></li><li><p>混合存储</p><ul><li>分散存储，但每一块内存里又是连续内存</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是数据结构&quot;&gt;&lt;a href=&quot;#什么是数据结构&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构&quot;&gt;&lt;/a&gt;什么是数据结构&lt;/h2&gt;&lt;p&gt;数据结构研究的是 &lt;strong&gt;数据 + 数据的逻辑结构 + API&lt;/strong&gt;，但我们需要</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://iiicon.github.io/blog-next/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="G" scheme="https://iiicon.github.io/blog-next/tags/G/"/>
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/tags/js/"/>
    
    <category term="数据结构" scheme="https://iiicon.github.io/blog-next/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vue2数据驱动</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/22/Vue2%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/22/Vue2%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</id>
    <published>2020-09-22T01:37:11.000Z</published>
    <updated>2021-12-21T06:04:02.223Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 的一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。当交互复杂的时候，只关心数据的修改会让代码的逻辑变得非常清晰，因为 DOM 变成了数据的映射，我们所有的修改都是修改数据，而不用触碰 DOM，这样的代码非常利于维护。</p><a id="more"></a><h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>Vue 定义：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">&quot;Vue is a constructor and should be called with the `new` keyword&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 只能通过 <code>new</code> 调用，然后执行 <code>_init</code> 方法（这将是 Vue2 最重要的一个方法）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// a uid</span></span><br><span class="line">  vm._uid = uid++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startTag, endTag;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">    mark(startTag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">  vm._isVue = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    initInternalComponent(vm, options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    initProxy(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm._self = vm;</span><br><span class="line">  initLifecycle(vm);</span><br><span class="line">  initEvents(vm);</span><br><span class="line">  initRender(vm);</span><br><span class="line">  callHook(vm, <span class="string">&quot;beforeCreate&quot;</span>);</span><br><span class="line">  initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm);</span><br><span class="line">  initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">&quot;created&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    vm._name = formatComponentName(vm, <span class="literal">false</span>);</span><br><span class="line">    mark(endTag);</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_init</code> 在实例化的时候就会调用，是 <code>Vue</code> 的核心，主要干了几件事情，合并配置，初始化事件中心，初始化渲染，初始化 data，初始化 props，初始化 computed，初始化 watcher 等等</p><p>下面列一下生命周期以及钩子的调用顺序，后面做剩余补充</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init.js</span><br><span class="line">- mergeOptions</span><br><span class="line">- initLifecycle</span><br><span class="line">- initEvents</span><br><span class="line">- initRender</span><br><span class="line">- callHook(vm, &#x27;beforeCreate&#x27;)</span><br><span class="line">- initInjections</span><br><span class="line">- initState</span><br><span class="line">  - initProps</span><br><span class="line">  - initMethods</span><br><span class="line">  - initData</span><br><span class="line">  - initComputed</span><br><span class="line">  - initWatch</span><br><span class="line">- initProvide</span><br><span class="line">- callHook(vm, &#x27;created&#x27;)</span><br></pre></td></tr></table></figure><h2 id="Vue-实例挂载的实现"><a href="#Vue-实例挂载的实现" class="headerlink" title="Vue 实例挂载的实现"></a>Vue 实例挂载的实现</h2><p><code>src/platform/web/entry-runtime-with-compiler.js</code> 中 <code>$mount</code> 的定义:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template);</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">          warn(<span class="string">&quot;invalid template option:&quot;</span> + template, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&quot;compile&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">        template,</span><br><span class="line">        &#123;</span><br><span class="line">          shouldDecodeNewlines,</span><br><span class="line">          shouldDecodeNewlinesForHref,</span><br><span class="line">          <span class="attr">delimiters</span>: options.delimiters,</span><br><span class="line">          <span class="attr">comments</span>: options.comments,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      );</span><br><span class="line">      options.render = render;</span><br><span class="line">      options.staticRenderFns = staticRenderFns;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&quot;compile&quot;</span>, <span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里首先缓存了原型上的 <code>$mount</code> 方法，首先对 <code>el</code> 做了限制，<code>Vue</code> 不能挂载在 <code>body html</code> 这样的根节点上，如果没有定义 <code>render</code> 方法，<del>则会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法。</del><br>这里我们要牢记，<code>Vue2</code> 版本中，所有 <code>Vue</code> 的组件的渲染最终都需要 <code>render</code> 方法，无论我们是用单文件 <code>.vue</code> 的方式开发组件还是写了 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法，那么这么过程是 <code>Vue</code> 的一个在线编译的过程，它是调用 <code>compileToFunctions</code> 方法实现的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>公共的 <code>$mount</code> 方法传入两个参数，第一个是 <code>el</code>，它表示挂载的元素，可以是字符串，也可以是 <code>DOM</code> 对象，第二个是否是服务端渲染，<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el: ?Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&quot;#&quot;</span>) ||</span><br><span class="line">        vm.$options.el ||</span><br><span class="line">        el</span><br><span class="line">      ) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&quot;You are using the runtime-only build of Vue where the template &quot;</span> +</span><br><span class="line">            <span class="string">&quot;compiler is not available. Either pre-compile the templates into &quot;</span> +</span><br><span class="line">            <span class="string">&quot;render functions, or use the compiler-included build.&quot;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&quot;Failed to mount component: template or render function not defined.&quot;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&quot;beforeMount&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name;</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid;</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render();</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag);</span><br><span class="line"></span><br><span class="line">      mark(startTag);</span><br><span class="line">      vm._update(vnode, hydrating);</span><br><span class="line">      mark(endTag);</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">          callHook(vm, <span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span>;</span><br><span class="line">    callHook(vm, <span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mountComponent</code> 核心就是实例化一个渲染 <code>Watcher</code>，在它的回调函数中调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法生成虚拟 <code>Node</code>，最终调用 <code>vm._update</code> 更新 <code>DOM</code><br>这里的 watcher 有两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测数据发生变化的时候执行回调函数，这里第四个参数是 watcher 构造函数的 options 参数之一，执行 <code>this.before = options.before</code> 保留了 <code>before</code> 钩子函数</p><p>函数最后判断为根节点的时候设置 <code>vm._isMounte</code>d 为 <code>true</code>，表示这个实例已经挂载了，同时执行 <code>mounted</code> 钩子函数。这里注意 <code>vm.$vnode</code> 表示 <code>Vue</code> 实例的父虚拟 <code>Node</code>，它是 <code>null</code> 表示是根 Vue 的实例</p><p>这里也涉及到了两个钩子函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new watcher(vm, updateComponent, noop, &#123;beforeUpdate&#125;)</span><br><span class="line">updateComponent</span><br><span class="line">callHook(vm, &#x27;mounted&#x27;)</span><br></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p><code>Vue</code> 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 <code>Node</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset _rendered flag on slots for duplicate slot check</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</span><br><span class="line">      <span class="comment">// $flow-disable-line</span></span><br><span class="line">      vm.$slots[key]._rendered = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.$vnode = _parentVnode;</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>);</span><br><span class="line">    <span class="comment">// return error render result,</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.$options.renderError) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.$options.renderError.call(</span><br><span class="line">            vm._renderProxy,</span><br><span class="line">            vm.$createElement,</span><br><span class="line">            e</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`renderError`</span>);</span><br><span class="line">          vnode = vm._vnode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm._vnode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&quot;Multiple root nodes returned from render function. Render function &quot;</span> +</span><br><span class="line">          <span class="string">&quot;should return a single root node.&quot;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    vnode = createEmptyVNode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode;</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码最关键的是 <code>render</code> 方法调用，我们在平时的开发工作中手写 <code>render</code> 方法的场景比较少，而写的比较多的是 <code>template</code> 模板，在之前的 <code>compileToFunctions</code> 方法的实现中，会把 template 编译成 <code>render</code> 方法，但这个编译过程是非常复杂的</p><p>我们知道 <code>render</code> 方法的第一个参数是 <code>createElement</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>相当于我们编写的 render 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">     <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;, <span class="built_in">this</span>.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到 <code>_render</code> 函数中的 <code>render</code> 方法的调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement);</span><br></pre></td></tr></table></figure><p>可以看到，<code>render</code> 函数中的 <code>createElement</code> 方法就是 <code>vm.$createElement</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上, <code>vm.$createElement</code> 方法的定义是在执行 <code>initRender</code> 方法的时候，可以看到还有一个<code> vm._c</code> 方法，它是被模板编译成的 <code>render</code> 函数调用，<code>vm.$createElement</code> 是用户手写 <code>render</code> 方法调用两个都调用 <code>createElement</code>，最后一个参数其实就是递归拍平 <code>children vnode</code></p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>虚拟 DOM 是在浏览器的真实 DOM 的前提下产生的，它产生的前提是 DOM 是很昂贵的，dom元素上面的属性非常多，频繁的更新它就会有性能上的问题</p><p>Virtural DOM 是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小的多。在 Vue 中，Virtual DOM 是用 VNode 这么一个 class 去描述</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: string,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: string,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = text</span><br><span class="line">    <span class="built_in">this</span>.elm = elm</span><br><span class="line">    <span class="built_in">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="built_in">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="built_in">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="built_in">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get child (): Component | <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VNode 是对真实 DOM 的一种抽象描述，它的定义无非就几个关键属性，标签名，数据，子节点，键值等等，其他属性都是用扩展 VNode 的，它只是有数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create diff patch 等过程。那么在 Vue.js 中，VNode 是通过之前提到的 createElement 方法创建的</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 的一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。当交互复杂的时候，只关心数据的修改会让代码的逻辑变得非常清晰，因为 DOM 变成了数据的映射，我们所有的修改都是修改数据，而不用触碰 DOM，这样的代码非常利于维护。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="vue2.x" scheme="https://iiicon.github.io/blog-next/tags/vue2-x/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2入口</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/21/Vue2%E5%85%A5%E5%8F%A3/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/21/Vue2%E5%85%A5%E5%8F%A3/</id>
    <published>2020-09-21T02:22:40.000Z</published>
    <updated>2021-12-21T06:04:02.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-应用-Runtime-Compiler-版本"><a href="#web-应用-Runtime-Compiler-版本" class="headerlink" title="web 应用 Runtime + Compiler 版本"></a>web 应用 Runtime + Compiler 版本</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime+compiler ES modules build (for direct import in browser)</span></span><br><span class="line">  <span class="string">&#x27;web-full-esm-browser-dev&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: resolve(<span class="string">&#x27;dist/vue.esm.browser.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">    <span class="attr">transpile</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><a id="more"></a><p>入口是 <code>src/platforms/web/entry-runtime-with-compiler.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&quot;core/config&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; warn, cached &#125; <span class="keyword">from</span> <span class="string">&quot;core/util/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mark, measure &#125; <span class="keyword">from</span> <span class="string">&quot;core/util/perf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;./runtime/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; query &#125; <span class="keyword">from</span> <span class="string">&quot;./util/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; compileToFunctions &#125; <span class="keyword">from</span> <span class="string">&quot;./compiler/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  shouldDecodeNewlines,</span><br><span class="line">  shouldDecodeNewlinesForHref,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./util/compat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id);</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template);</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">          warn(<span class="string">&quot;invalid template option:&quot;</span> + template, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&quot;compile&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">        template,</span><br><span class="line">        &#123;</span><br><span class="line">          shouldDecodeNewlines,</span><br><span class="line">          shouldDecodeNewlinesForHref,</span><br><span class="line">          <span class="attr">delimiters</span>: options.delimiters,</span><br><span class="line">          <span class="attr">comments</span>: options.comments,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      );</span><br><span class="line">      options.render = render;</span><br><span class="line">      options.staticRenderFns = staticRenderFns;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&quot;compile&quot;</span>, <span class="string">&quot;compile end&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get outerHTML of elements, taking care</span></span><br><span class="line"><span class="comment"> * of SVG elements in IE as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span>(<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.compile = compileToFunctions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><h2 id="Vue-的入口"><a href="#Vue-的入口" class="headerlink" title="Vue 的入口"></a>Vue 的入口</h2><p>在这个入口 JS 的上方我们可以找到 Vue 的来源：<code>import Vue from &#39;./runtime/index&#39;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;core/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&quot;core/config&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; extend, noop &#125; <span class="keyword">from</span> <span class="string">&quot;shared/util&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mountComponent &#125; <span class="keyword">from</span> <span class="string">&quot;core/instance/lifecycle&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; devtools, inBrowser, isChrome &#125; <span class="keyword">from</span> <span class="string">&quot;core/util/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  query,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  isReservedAttr,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  isUnknownElement,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;web/util/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; patch &#125; <span class="keyword">from</span> <span class="string">&quot;./patch&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> platformDirectives <span class="keyword">from</span> <span class="string">&quot;./directives/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> platformComponents <span class="keyword">from</span> <span class="string">&quot;./components/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform specific utils</span></span><br><span class="line">Vue.config.mustUseProp = mustUseProp;</span><br><span class="line">Vue.config.isReservedTag = isReservedTag;</span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr;</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace;</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform runtime directives &amp; components</span></span><br><span class="line">extend(Vue.options.directives, platformDirectives);</span><br><span class="line">extend(Vue.options.components, platformComponents);</span><br><span class="line"></span><br><span class="line"><span class="comment">// install platform patch function</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  el?: string | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p>我们发现 <code>import Vue from &#39;core/index&#39;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;./instance/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">&quot;./global-api/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">&quot;core/util/env&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FunctionalRenderContext &#125; <span class="keyword">from</span> <span class="string">&quot;core/vdom/create-functional-component&quot;</span>;</span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&quot;$isServer&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: isServerRendering,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&quot;$ssrContext&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$vnode &amp;&amp; <span class="built_in">this</span>.$vnode.ssrContext;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expose FunctionalRenderContext for ssr runtime helper installation</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&quot;FunctionalRenderContext&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: FunctionalRenderContext,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">&quot;__VERSION__&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p>其中引入 <code>import Vue from &#39;./instance/index&#39;</code> 和 <code>initGlobalAPI(Vue)</code>，初始化全局 Vue API</p><h2 id="Vue-的定义"><a href="#Vue-的定义" class="headerlink" title="Vue 的定义"></a>Vue 的定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&quot;./init&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&quot;./state&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&quot;./render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&quot;./events&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&quot;./lifecycle&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&quot;../util/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">&quot;Vue is a constructor and should be called with the `new` keyword&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p>这里就是 <code>Vue</code> 的构造函数，这里分成了很多的 <code>mixin</code>，并把 <code>Vue</code> 传入，它们的功能都是给 <code>Vue.prototype</code> 上扩展一些方法，这样就把不同的功能代码分到了不同的模块去实现，也便于代码的维护和管理。</p><h2 id="initGlobalAPI"><a href="#initGlobalAPI" class="headerlink" title="initGlobalAPI"></a><code>initGlobalAPI</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// config</span></span><br><span class="line">  <span class="keyword">const</span> configDef = &#123;&#125;;</span><br><span class="line">  configDef.get = <span class="function">() =&gt;</span> config;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    configDef.set = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&quot;Do not replace the Vue.config object, set individual fields instead.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&quot;config&quot;</span>, configDef);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exposed util methods.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on</span></span><br><span class="line">  <span class="comment">// them unless you are aware of the risk.</span></span><br><span class="line">  Vue.util = &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Vue.set = set;</span><br><span class="line">  Vue.delete = del;</span><br><span class="line">  Vue.nextTick = nextTick;</span><br><span class="line"></span><br><span class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  ASSET_TYPES.forEach(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">    Vue.options[type + <span class="string">&quot;s&quot;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue;</span><br><span class="line"></span><br><span class="line">  extend(Vue.options.components, builtInComponents);</span><br><span class="line"></span><br><span class="line">  initUse(Vue);</span><br><span class="line">  initMixin(Vue);</span><br><span class="line">  initExtend(Vue);</span><br><span class="line">  initAssetRegisters(Vue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initGlobalAPI</code> 是扩展 <code>Vue</code> 的静态方法的定义，这些方法是全局 API，官方文档都有</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;web-应用-Runtime-Compiler-版本&quot;&gt;&lt;a href=&quot;#web-应用-Runtime-Compiler-版本&quot; class=&quot;headerlink&quot; title=&quot;web 应用 Runtime + Compiler 版本&quot;&gt;&lt;/a&gt;web 应用 Runtime + Compiler 版本&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Runtime+compiler ES modules build (for direct import in browser)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;#x27;web-full-esm-browser-dev&amp;#x27;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;entry&lt;/span&gt;: resolve(&lt;span class=&quot;string&quot;&gt;&amp;#x27;web/entry-runtime-with-compiler.js&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;dest&lt;/span&gt;: resolve(&lt;span class=&quot;string&quot;&gt;&amp;#x27;dist/vue.esm.browser.js&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;format&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;es&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;transpile&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;env&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;development&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;alias&lt;/span&gt;: &amp;#123; &lt;span class=&quot;attr&quot;&gt;he&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;./entity-decoder&amp;#x27;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    banner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="vue2.x" scheme="https://iiicon.github.io/blog-next/tags/vue2-x/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x源码目录设计</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/21/Vue2%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/21/Vue2%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-09-21T01:38:45.000Z</published>
    <updated>2021-12-21T06:04:02.226Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 的源码都在 src 目录下，其目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></table></figure><!-- more  --><h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast语法树优化，代码生成等功能</p><p>编译的功能可以在构建时做（借助 webpack，vue-loader 等辅助插件），也可以运行时做，使用包含构建功能的 Vue.js。显然编译是一项耗性能的工作，所以更推荐前者 —— 离线编译</p><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core 目录包含了 Vue.js 的核心代码，包含内置组件、全局 API 封装，Vue 实例化、观察者、虚拟DOM、工具函数等等</p><p>这里的代码就是 Vue.js 的核心代码</p><h2 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h2><p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2个目录代表两个入口，分别打包成运行在 web 和 weex 上的 Vue.js</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染的相关逻辑都在这个目录下。注意：这部分代码是跑在服务端的 node.js，不要和跑在浏览器端的 Vue.js 混为一谈</p><p>服务端渲染主要的工作是把组件渲染为服务端的 HTML 字符串，将他们直接发送到浏览器，最后将静态标记混合为客户端上完全交互的应用程序</p><h2 id="sfc"><a href="#sfc" class="headerlink" title="sfc"></a>sfc</h2><p>通常我们开发 Vue.js 都会借助 webpack，然后通过 .vue 单文件来编写组件。这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 对象</p><h2 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h2><p>从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue.js 的源码都在 src 目录下，其目录结构如下&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;src&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="vue2.x" scheme="https://iiicon.github.io/blog-next/tags/vue2-x/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码阅读笔记</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/14/vuex%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/14/vuex%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-14T07:36:42.000Z</published>
    <updated>2021-12-21T06:04:02.323Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuex:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&#x27;__VERSION__&#x27;</span>,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vuex</code> 提供了一个 <code>install</code> 方法用来注册插件，我们 <code>use</code> 的时候就会执行，并把 <code>Vue</code> 作为参数传入，执行 <code>install</code> 会执行 <code>applyMixin(Vue)</code>，这个函数就是全局混入了 <code>beforeCreate</code> 钩子，在这个钩子中报错了 <code>this.$store = options.store</code>，并通过 <code>vm.parent</code> 把所有的组件都添加这个属性</p><h2 id="Store-实例化"><a href="#Store-实例化" class="headerlink" title="Store 实例化"></a>Store 实例化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  modules</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实例化过程执行 Store 的 constructor，主要步骤有三步</p><ol><li><code>this._modules = new ModuleCollection(options)</code> 初始化模块</li><li><code>installModule(this, state, [], this._modules.root)</code> 安装模块</li><li><code>resetStoreVM(this, state)</code> 初始化 store._vm</li></ol><h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><p>vuex 设计成不仅仅可以在根实例上初始化状态，也允许分割成一个个 module，每个模块拥有自己的 state mutation action getter，而且可以无限嵌套</p><p>从数据结构上来看，模块的设计就是一个树形结构，store 本身可以理解为一个 root module，它下面的 modules 就是子模块， vux 需要完成这棵树的构建，构建的入口就是 <code>this._modules = new ModuleCollection(options)</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">rawRootModule</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// register root module (Vuex.Store options)</span></span><br><span class="line">    <span class="built_in">this</span>.register([], rawRootModule, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">    &#125;, <span class="built_in">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getNamespace</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key)</span><br><span class="line">      <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">&#x27;/&#x27;</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">rawRootModule</span>)</span> &#123;</span><br><span class="line">    update([], <span class="built_in">this</span>.root, rawRootModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">register</span>(<span class="params">path, rawModule, runtime = <span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      assertRawModule(path, rawModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime)</span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = newModule</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = <span class="built_in">this</span>.get(path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">      parent.addChild(path[path.length - <span class="number">1</span>], newModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register nested modules</span></span><br><span class="line">    <span class="keyword">if</span> (rawModule.modules) &#123;</span><br><span class="line">      forEachValue(rawModule.modules, <span class="function">(<span class="params">rawChildModule, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.register(path.concat(key), rawChildModule, runtime)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">unregister</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="built_in">this</span>.get(path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> key = path[path.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (!parent.getChild(key).runtime) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    parent.removeChild(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法，它接受三个参数，<code>path</code> 表示路径， 表示定义模块的原始配置，<code>runtime</code> 表示是否是一个运行时创建的模块</p><p><code>register</code> 方法首先通过 <code>const newModule = new Module(rawModule, runtime)</code> 创建了一个 <code>Module</code> 的实例，<code>Module</code> 是用来描述单个模块的类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">rawModule, runtime</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.runtime = runtime</span><br><span class="line">    <span class="comment">// Store some children item</span></span><br><span class="line">    <span class="built_in">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// Store the origin module object which passed by programmer</span></span><br><span class="line">    <span class="built_in">this</span>._rawModule = rawModule</span><br><span class="line">    <span class="keyword">const</span> rawState = rawModule.state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the origin module&#x27;s state</span></span><br><span class="line">    <span class="built_in">this</span>.state = (<span class="keyword">typeof</span> rawState === <span class="string">&#x27;function&#x27;</span> ? rawState() : rawState) || &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">namespaced</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="built_in">this</span>._rawModule.namespaced</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addChild</span>(<span class="params">key, <span class="built_in">module</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._children[key] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">removeChild</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>._children[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChild</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._children[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">rawModule</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._rawModule.namespaced = rawModule.namespaced</span><br><span class="line">    <span class="keyword">if</span> (rawModule.actions) &#123;</span><br><span class="line">      <span class="built_in">this</span>._rawModule.actions = rawModule.actions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rawModule.mutations) &#123;</span><br><span class="line">      <span class="built_in">this</span>._rawModule.mutations = rawModule.mutations</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rawModule.getters) &#123;</span><br><span class="line">      <span class="built_in">this</span>._rawModule.getters = rawModule.getters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">forEachChild</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    forEachValue(<span class="built_in">this</span>._children, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">forEachGetter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._rawModule.getters) &#123;</span><br><span class="line">      forEachValue(<span class="built_in">this</span>._rawModule.getters, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">forEachAction</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._rawModule.actions) &#123;</span><br><span class="line">      forEachValue(<span class="built_in">this</span>._rawModule.actions, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">forEachMutation</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._rawModule.mutations) &#123;</span><br><span class="line">      forEachValue(<span class="built_in">this</span>._rawModule.mutations, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过递归调用 register 函数，就会建议一颗完整的 module 树</p><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>对模块中 state getters mutations actions 做初始化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state</span><br><span class="line">installModule(<span class="built_in">this</span>, state, [], <span class="built_in">this</span>._modules.root)</span><br></pre></td></tr></table></figure><p>installModule 的定义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>installModule</code> 支持五个参数，<code>store</code> 表示 <code>root</code> <code>store</code>；<code>state</code> 表示 <code>root</code> <code>state</code>，<code>path</code> 表示模块的访问路径；<code>module</code> 表示当前的模块，<code>hot</code> 表示是否热更新</p><p>默认情况下，模块内部的 <code>mutation</code> <code>action</code> <code>getter</code> 是注册在全局命名空间的，如果添加 <code>namespace:true</code>, 当模块被注册后，他的所有 <code>getter</code> <code>action</code> <code>mutation</code> 都会自动根据模块注册的路径调整命名</p><p>回到 <code>installModule</code> 方法，我们首先根据 <code>path</code> 获取 <code>namespace</code>，返回 / 拼接的字符串或者空字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getNamespace (path) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="built_in">this</span>.root</span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key)</span><br><span class="line">    <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">&#x27;/&#x27;</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pip install virtualenv  -i https:<span class="comment">//pypi.douban.com/simple</span></span><br><span class="line">pip install apache-superset -i https:<span class="comment">//pypi.douban.com/simple</span></span><br><span class="line">flask fab  create-admin</span><br><span class="line">set FLASK_APP=superset</span><br><span class="line">set FLASK_ENV=development</span><br><span class="line">python superset db upgrade</span><br><span class="line">python superset init</span><br><span class="line">python superset runserver</span><br></pre></td></tr></table></figure><p>接着 <code>namespaced</code> 为 <code>true</code> 则把 <code>module</code> 保存到 <code>_modulesNamespaceMap</code> <code>store._modulesNamespaceMap[namespace] = module</code></p><p>接着判断 isroot 为 false 就把 parentState 和 module.state 设置属性关系 <code>Vue.set(parentState, moduleName, module.state)</code>，值得一提的是，<code>_withCommit</code> 保证是 <code>commit</code> 提交的，直接修改在 <code>strict</code> 模式下会报错</p><p>接着执行 <code>const local = module.context = makeLocalContext(store, namespace, path)</code> 生成 local 对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span>(<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = &#123;</span><br><span class="line">    <span class="attr">dispatch</span>: noNamespace</span><br><span class="line">      ? store.dispatch</span><br><span class="line">      : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">          <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">          <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">            type = namespace + type</span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !store._actions[type]) &#123;</span><br><span class="line">              <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> store.dispatch(type, payload)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">commit</span>: noNamespace</span><br><span class="line">      ? store.commit</span><br><span class="line">      : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">          <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">          <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">            type = namespace + type</span><br><span class="line">            <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !store._mutations[type]) &#123;</span><br><span class="line">              <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local mutation type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          store.commit(type, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and state object must be gotten lazily</span></span><br><span class="line">  <span class="comment">// because they will be changed by vm update</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">      <span class="attr">get</span>: noNamespace ? <span class="function">() =&gt;</span> store.getters : <span class="function">() =&gt;</span> makeLocalGetters(store, namespace)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> getNestedState(store.state, path)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法定义了 <code>local</code> 对象，对于 <code>dispatch</code> 和 <code>commit</code> 方法，如果没有 <code>namespace</code>，它们就直接指向了 <code>root store</code> 的 <code>dispatch</code> 和 <code>commit</code> 方法，否则会创建方法，把 <code>type</code> 自动拼接上 <code>namespace</code>，然后执行 <code>store</code> 上对应的方法<br>对于 <code>getters</code> 而言，如果没有 <code>namespace</code>，则直接返回 <code>root store</code> 的 <code>getters</code>，否则返回 <code>makeLocalGetters(store, namespace)</code> 的返回值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalGetters</span>(<span class="params">store, namespace</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gettersProxy = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> splitPos = namespace.length</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(store.getters).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// skip if the target getter is not match this namespace</span></span><br><span class="line">    <span class="keyword">if</span> (type.slice(<span class="number">0</span>, splitPos) !== namespace) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extract local getter type</span></span><br><span class="line">    <span class="keyword">const</span> localType = type.slice(splitPos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a port to the getters proxy.</span></span><br><span class="line">    <span class="comment">// Define as getter property because</span></span><br><span class="line">    <span class="comment">// we do not want to evaluate the getters in this time.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> store.getters[type],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gettersProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeLocalGetters</code> 首先获取 <code>namespace</code> 长度，然后遍历 <code>root store</code> 下所有的 <code>getters</code>, 如果符合 <code>namespace</code>, 就截取后面的 <code>localType</code>，用 <code>Object.defineProperty</code> 定义了 <code>gettersProxy</code>, 获取 <code>localType</code> 实际上是访问了 <code>store.getters[type]</code></p><p><code>state</code> 相对比较简单，就根据 <code>path</code> 查找 <code>state</code></p><p>构造完 <code>local</code> 上下文后，我们回调 <code>installModule</code> 方法，接下来他会遍历模块中定义的<code>mutations actions getters</code> 分别执行他们的注册工作，<br>过程就是执行 <code>registerMutaions</code> 给 <code>rootStore</code> 的 <code>_mutations[types]</code> 添加 <code>wrappedMutationHandler</code> 方法，<br>执行 <code>registerActions</code> 给 <code>root store</code> 的 <code>_actions[types]</code> 添加 <code>wrappedActionHandler</code> 方法，<br>执行 <code>registerGetter</code> 给 <code>root store</code> 上的 <code>_wrappedGetters[key]</code> 指定 <code>wrappedGetter</code> 方法</p><p>再回到 <code>installModule</code> 方法，最后一步就是遍历模块中的所有子 <code>modules</code>，递归执行 <code>installModule</code> 方法</p><p><code>installModule</code> 实际上就是完成了模块下的<code>state、getters、actions、mutations</code> 的初始化工作，并且通过递归遍历的方式，就完成了所有子模块的安装工作。</p><h3 id="初始化-store-vm"><a href="#初始化-store-vm" class="headerlink" title="初始化 store._vm"></a>初始化 <code>store._vm</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store._vm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    computed[key] = <span class="function">() =&gt;</span> fn(store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line">  <span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line">  <span class="comment">// some funky global mixins</span></span><br><span class="line">  <span class="keyword">const</span> silent = Vue.config.silent</span><br><span class="line">  Vue.config.silent = <span class="literal">true</span></span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">$$state</span>: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new vm</span></span><br><span class="line">  <span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(<span class="function">() =&gt;</span> oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resetStoreVM</code> 的作用就是想建立 <code>getters</code> 和 <code>state</code> 的联系，因为从设计上 <code>getters</code> 的获取就依赖了<code>state</code>，并且希望它的依赖能被缓存起来，且只有依赖值发生变化才会重新计算，这里直接用了 <code>vue</code> 的 <code>computed</code> 实现</p><p><code>resetStoreVM</code> 首先遍历了 <code>_wrappedGetters</code> 获取每个 <code>getter</code> 的函数 <code>fn</code> 和 <code>key</code>，然后定义了 <code>computed[key] = () =&gt; fn(store)</code>, 这里的 <code>fn(store)</code> 就相当于执行 <code>wrapperGetter</code>, 返回的就是 <code>rawGetter</code> 执行函数，<code>rawGetter</code> 就是用户定义的 <code>getter</code> 函数，他的前两个参数是 <code>local state</code> 和 <code>local getters</code>，后两个参数就是 <code>root state</code> 和 <code>root getters</code><br>接着实例化一个 <code>vue</code> 实例，<code>store._vm</code> 并把 <code>computed</code> 传入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">$$state</span>: state</span><br><span class="line">  &#125;,</span><br><span class="line">  computed</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们发现 data 选项里定义了 <code>$$state</code> 属性，而我们访问 <code>store.state</code> 的时候，实际上会访问 <code>store</code> 类上定义的 <code>state</code> 的 <code>get</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">get state () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._vm._data.$$state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是访问的 <code>$$state</code>，那么 <code>getters</code> 和 <code>state</code> 是如何建立依赖逻辑的呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">  computed[key] = <span class="function">() =&gt;</span> fn(store)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我根据 <code>key</code> 访问 <code>store.getters</code> 的某一个 <code>getter</code> 的时候，实际上就是访问了 <code>store._vm[key]</code>，也就是 <code>computed[key]</code>，在执行 <code>computed[key]</code> 对应的函数的时候，会执行 <code>rawGetter(local.state,..)</code> 方法，那么就会访问到 <code>store.state</code>, 进而访问到 <code>$$state</code>, 这样就建立了一个依赖关系</p><p>当严格模式下，<code>store._vm</code> 会添加一个 <code>wathcer</code> 来观测 <code>this._data.$$state</code> 的变化，也就是当 <code>store.state</code> 被修改的时候, <code>store._committing</code> 必须为 <code>true</code>，否则在开发阶段会报警告。<code>store._committing</code> 默认值是 <code>false</code>，那么它什么时候会 <code>true</code> 呢，<code>Store</code> 定义了 <code>_withCommit</code> 实例方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="built_in">this</span>._committing</span><br><span class="line">  <span class="built_in">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="built_in">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它就是对 <code>fn</code> 包装了一个环境，确保在 <code>fn</code> 中执行任何逻辑的时候 <code>this._committing = true</code>。所以外部任何非通过 <code>Vuex</code> 提供的接口直接操作修改 <code>state</code> 的行为都会在开发阶段触发警告。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>对 <code>store</code> 做存取的操作</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>``Vuex<code>最终存储的数据是在 state 上，我们之前分析过在</code>store.state<code>存储的是</code>root state<code>, 那么对于模块上的</code>state<code>，假设我们有 2个嵌套的</code>modules<code>，他们的</code>key<code>分别为</code>a<code>和</code>b<code>，我们可以 通过</code>store.state.a.b.xxx<code>的方式去获取</code><br>它的实现发生在 <code>installModule</code> 的时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归执行 installModule 的过程中，递归执行了所有 getters 定义的注册，在之后的 resetStoreVM 过程中，执行了 store.getters 的初始化工作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span>(<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    computed[key] = <span class="function">() =&gt;</span> fn(store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use a Vue instance to store the state tree</span></span><br><span class="line">  <span class="comment">// suppress warnings just in case the user has added</span></span><br><span class="line">  <span class="comment">// some funky global mixins</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">$$state</span>: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>installModule</code> 的过程中，建立了每个模块的上下文环境，因此当我们访问 <code>store.getters.xxx</code> 的时候，实际上就是执行 <code>rawGetter(local.state, local.getters, root.state, root.getters)</code></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><code>Vuex</code> 对数据存储本质上就是对 <code>state</code> 做修改，并且只允许我们通过提交 <code>mutation</code> 的形式去修改 <code>state</code>，<code>mutation</code> 是一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mutations</code> 的初始化也是在 <code>installModule</code> 的时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry =</span><br><span class="line">    store._mutations[type] ||</span><br><span class="line">    (store._mutations[type] = []) -</span><br><span class="line">      entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">        handler.call(store, local.state, payload)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store</code> 提供了一个 <code>commit</code> 方法提交一个 <code>mutation</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">  <span class="comment">// check object-style commit</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload,</span><br><span class="line">    options</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">      handler(payload)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>._subscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="built_in">this</span>.state))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    options &amp;&amp; options.silent</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(</span><br><span class="line">      <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class="line">      <span class="string">&#x27;Use the filter functionality in the vue-devtools&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 <code>this._mutations</code> 获取每个 <code>handler(payload)</code> 执行，实际就是执行了 <code>wrappedMutationHandler(payload)</code>，然后执行我们定义在 <code>mutation</code> 的函数, 传入 并 <code>local.state</code></p><p>需要注意的是 <code>mutation</code> 必须是同步函数，因为我们有异步的需求，所以 <code>action</code> 也经常用到</p><p><code>action</code> 类似于 <code>mutation</code>，不同在于 <code>action</code> 提交的是 <code>mutation</code>，而不是直接操作 <code>state</code>，并且它可以包含任意异步操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  increment (context) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>actions 的初始化也是在 installModule 的时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, namespace, path))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span>(<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span>(<span class="params">payload, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.call(</span><br><span class="line">      store,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">dispatch</span>: local.dispatch,</span><br><span class="line">        <span class="attr">commit</span>: local.commit,</span><br><span class="line">        <span class="attr">getters</span>: local.getters,</span><br><span class="line">        <span class="attr">state</span>: local.state,</span><br><span class="line">        <span class="attr">rootGetters</span>: store.getters,</span><br><span class="line">        <span class="attr">rootState</span>: store.state</span><br><span class="line">      &#125;,</span><br><span class="line">      payload,</span><br><span class="line">      cb</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">&#x27;vuex:error&#x27;</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store</code> 提供了一个 <code>dispatch</code> 方法让我们提交一个 <code>action</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  <span class="comment">// check object-style dispatch</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = &#123; type, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="built_in">this</span>._actions[type]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown action type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._actionSubscribers.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(action, <span class="built_in">this</span>.state))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entry.length &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">    : entry[<span class="number">0</span>](payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 <code>store._actions</code> 中对应的数组，找个每个 <code>handler</code> 然后执行 <code>wrappedActionHandler(payload)</code>，接着会执行我们定义的 <code>action</code> 函数，<br>并传入了一个对象，包含当前模块的 <code>dispatch</code> <code>commit</code> <code>getters</code> <code>state</code> 以及全局的 <code>rootState</code> <code>rootGetters</code>, 所以我们定义的 <code>action</code> 函数能拿到<br>当前模块下的 <code>commit</code> 方法,</p><p><strong>因此 action 比我们自己写一个函数执行异步操作然后提交 mutation 的好处是在于它可以在参数中获取到当前模块的一些方法和状态，Vuex 帮我们做好了这些</strong></p><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><p>用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    <span class="function"><span class="title">countPlusLocalState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = normalizeNamespace(<span class="function">(<span class="params">namespace, states</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(states).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> state = <span class="built_in">this</span>.$store.state</span><br><span class="line">      <span class="keyword">let</span> getters = <span class="built_in">this</span>.$store.getters</span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(<span class="built_in">this</span>.$store, <span class="string">&#x27;mapState&#x27;</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="built_in">module</span>.context.state</span><br><span class="line">        getters = <span class="built_in">module</span>.context.getters</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ? val.call(<span class="built_in">this</span>, state, getters) : state[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeNamespace</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">namespace, map</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> namespace !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      map = namespace</span><br><span class="line">      namespace = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (namespace.charAt(namespace.length - <span class="number">1</span>) !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">      namespace += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(namespace, map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeMap</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(map) ? map.map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: key &#125;)) : <span class="built_in">Object</span>.keys(map).map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; key, <span class="attr">val</span>: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>mapState(map)</code> 函数的时候，实际上就是执行 <code>normalizeNamespace</code> 包裹的函数，然后把 <code>map</code> 作为参数 <code>states</code> 传入，<code>mapState</code> 最终要构建一个对象，每个对象的元素都是一个方法，因为这个对象是要扩展到组件的 <code>computed</code> 属性的。<br>函数首先执行 <code>normalizeMap</code> 方法，把这个 <code>states</code> 变成一个数组，数组的每个元素都是 <code>key:value</code> 的形式，然后再遍历这个数组，以 <code>key</code> 作为对象的 <code>key</code>，值为一个 <code>mappedState</code> 函数，在这个 函数内部获取 <code>$store.state</code> 和 <code>$store.getters</code>,<br>如果 <code>val</code> 是函数就行，否则直接访问 <code>state[val]</code></p><p>如果是模块中的 state，我们可以这样写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  mapState(<span class="string">&#x27;some/nested/module&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 mapState 基本类似</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = normalizeNamespace(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(getters).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// thie namespace has been mutate by normalizeNamespace</span></span><br><span class="line">    val = namespace + val</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (namespace &amp;&amp; !getModuleByNamespace(<span class="built_in">this</span>.$store, <span class="string">&#x27;mapGetters&#x27;</span>, namespace)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(val <span class="keyword">in</span> <span class="built_in">this</span>.$store.getters)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown getter: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].vuex = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mapMutaions"><a href="#mapMutaions" class="headerlink" title="mapMutaions"></a>mapMutaions</h4><p>我们可以在组件中使用 <code>this.$store.commit(&#39;xx&#39;)</code> 提交 <code>mutation</code>，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code></p><p>用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapMutations 支持传入一个数组或者对象，目标都是组件中对应的 methods 映射为 store.commit 的调用</p><p>定义：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = normalizeNamespace(<span class="function">(<span class="params">namespace, mutations</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(mutations).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedMutation</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Get the commit method from store</span></span><br><span class="line">      <span class="keyword">let</span> commit = <span class="built_in">this</span>.$store.commit</span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(<span class="built_in">this</span>.$store, <span class="string">&#x27;mapMutations&#x27;</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        commit = <span class="built_in">module</span>.context.commit</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ? val.apply(<span class="built_in">this</span>, [commit].concat(args)) : commit.apply(<span class="built_in">this</span>.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到 <code>mappedMutation</code> 同样支持了 <code>namespace</code>, 并且支持了传入额外的参数 <code>args</code>，作为提交 <code>mutation</code> 的 <code>payload</code>, 最终就是执行了 <code>store.commit</code> 方法，并且这个 <code>commit</code> 会根据传入的 <code>namespace</code> 映射到对应 <code>module</code> 的 <code>commit</code> 上</p><h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><p>我们可以在组件中使用 <code>this.$store.dispatch(&#39;xx&#39;)</code> 提交 <code>action</code>，或者使用 <code>mapActions</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.dispatch</code> 的调用</p><p>定义，和 mapMutaions 基本一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = normalizeNamespace(<span class="function">(<span class="params">namespace, actions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  normalizeMap(actions).forEach(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    res[key] = <span class="function"><span class="keyword">function</span> <span class="title">mappedAction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// get dispatch function from store</span></span><br><span class="line">      <span class="keyword">let</span> dispatch = <span class="built_in">this</span>.$store.dispatch</span><br><span class="line">      <span class="keyword">if</span> (namespace) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = getModuleByNamespace(<span class="built_in">this</span>.$store, <span class="string">&#x27;mapActions&#x27;</span>, namespace)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">module</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch = <span class="built_in">module</span>.context.dispatch</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ? val.apply(<span class="built_in">this</span>, [dispatch].concat(args)) : dispatch.apply(<span class="built_in">this</span>.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态更新模块"><a href="#动态更新模块" class="headerlink" title="动态更新模块"></a>动态更新模块</h3><p>在 <code>Vuex</code> 初始化阶段我们构造了模块树，初始化了模块上各个部分。在有一些场景下，我们需要动态去注入一些新的模块，<code>Vuex</code> 提供了模块动态注册功能，在 <code>store</code> 上提供了一个 <code>registerModule</code> 的 <code>API</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">registerModule (path, rawModule, options = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">&#x27;string&#x27;</span>) path = [path]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    assert(<span class="built_in">Array</span>.isArray(path), <span class="string">`module path must be a string or an Array.`</span>)</span><br><span class="line">    assert(path.length &gt; <span class="number">0</span>, <span class="string">&#x27;cannot register the root module by using registerModule.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._modules.register(path, rawModule)</span><br><span class="line">  installModule(<span class="built_in">this</span>, <span class="built_in">this</span>.state, path, <span class="built_in">this</span>._modules.get(path), options.preserveState)</span><br><span class="line">  <span class="comment">// reset store to update getters...</span></span><br><span class="line">  resetStoreVM(<span class="built_in">this</span>, <span class="built_in">this</span>.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个卸载的函数，当然这里只会卸载动态创建的模块</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">unregisterModule (path) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">&#x27;string&#x27;</span>) path = [path]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    assert(<span class="built_in">Array</span>.isArray(path), <span class="string">`module path must be a string or an Array.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._modules.unregister(path)</span><br><span class="line">  <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(<span class="built_in">this</span>.state, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    Vue.delete(parentState, path[path.length - <span class="number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  resetStore(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="vue2.x" scheme="https://iiicon.github.io/blog-next/tags/vue2-x/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="vuex" scheme="https://iiicon.github.io/blog-next/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 源码阅读笔记</title>
    <link href="https://iiicon.github.io/blog-next/2020/09/02/vue-router%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://iiicon.github.io/blog-next/2020/09/02/vue-router%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-02T09:22:46.000Z</published>
    <updated>2021-12-21T06:04:02.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>使用 <code>Vue.js + Vue Router</code> 创建单页只需要将组件 <code>components</code> 映射到路由 <code>routes</code>，然后告诉 <code>Vue Router</code> 在哪里渲染它们</p><a id="more"></a><h2 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h2><p>Vue 主要是解决视图渲染的问题，其他的能力是通过插件的方式解决</p><h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a><code>Vue.use</code></h3><p>Vue 提供了 use 的全局 API 来注册这些插件，定义在 <code>vue/src/core/global-api/use.js</code> 中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span>(<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="built_in">this</span>._installedPlugins || (<span class="built_in">this</span>._installedPlugins = [])</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue.use</code> 接受一个 <code>plugin</code> 参数，并且维护了一个 <code>_installPlugins</code> 数组，并存储所有注册过的 <code>plugins</code>,<br>接着判断 <code>install</code> 方法有没有定义，有则调用，注意第一个参数 <code>Vue</code>，最后把 plugin 存储在 <code>_installPlugins</code> 中</p><h3 id="路由安装"><a href="#路由安装" class="headerlink" title="路由安装"></a>路由安装</h3><p>Vue-Router 的入口文件是 <code>src/index.js</code>，其中定义了 <code>VueRouter</code> 类，挂载了 <code>install</code> 方法 <code>VueRouter.install = install</code></p><p>当我们执行 <code>Vue.use(VueRouter)</code> 的时候，就是执行了 <code>install</code> 方法，其中最重要的就是 通过 <code>Vue.mixin</code> 方法把 <code>beforeCreate</code> 和 <code>destroyed</code> 钩子注入到每一个组件中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">mixin: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = mergeOptions(<span class="built_in">this</span>.options, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实就是把定义的对象混入了 <code>Vue.options</code> 中，因为我们在组件创建阶段会执行 <code>extend</code> 把 <code>Vue.options</code> merge 到自身的 <code>options</code> 中，所以相当于每个组件都混入了这两个钩子</p><p>我们再看 <code>install</code> 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="keyword">return</span></span><br><span class="line">  install.installed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="keyword">if</span> (isDef(i) &amp;&amp; isDef((i = i.data)) &amp;&amp; isDef((i = i.registerRouteInstance))) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="built_in">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._routerRoot = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">this</span>._router = <span class="built_in">this</span>.$options.router</span><br><span class="line">        <span class="built_in">this</span>._router.init(<span class="built_in">this</span>)</span><br><span class="line">        Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;_route&#x27;</span>, <span class="built_in">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._routerRoot = (<span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent._routerRoot) || <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      registerInstance(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._router</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$route&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterView&#x27;</span>, View)</span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterLink&#x27;</span>, Link)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入的 <code>beforeCreate</code> 钩子，对于根 Vue 实例而言，执行该钩子 <code>this._routerRoot</code> 就是自身，<code>this._router</code> 表示 <code>router</code> 实例，然后执行 <code>this._router.init()</code> 初始化 <code>router</code>,<br>接着用 <code>defineReactive</code> 把 <code>this._router</code> 变成响应式对象<br>对于子组件的 <code>_routerRoot</code> 始终指向的离它最近的传入了 <code>router</code> 对象作为配置而实例化的父实例。</p><p><code>beforeCreate</code> 和 <code>destroyed</code> 钩子都会执行 vnode 定义的 <code>registerInstance</code></p><p>接着在实例原型上定义了 <code>$router</code> 和 <code>$route</code> 2 个属性的 get 方法，我们可以 <code>this.$router</code> 以及 <code>this.$route</code> 去访问 router</p><p>接着通过 <code>Vue.component</code> 方法定义了全局的 <code>router-view</code> 和 <code>router-link</code> 组件</p><p>最后定义了 <code>Vue Router</code> 钩子函数用 Vue 的 <code>created</code> 的钩子合并策略</p><h2 id="VueRouter-对象"><a href="#VueRouter-对象" class="headerlink" title="VueRouter 对象"></a>VueRouter 对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> install: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">static</span> version: string</span><br><span class="line"></span><br><span class="line">  <span class="attr">app</span>: any</span><br><span class="line">  <span class="attr">apps</span>: <span class="built_in">Array</span>&lt;any&gt;</span><br><span class="line">  ready: boolean</span><br><span class="line">  <span class="attr">readyCbs</span>: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  options: RouterOptions</span><br><span class="line">  <span class="attr">mode</span>: string</span><br><span class="line">  <span class="attr">history</span>: HashHistory | HTML5History | AbstractHistory</span><br><span class="line">  <span class="attr">matcher</span>: Matcher</span><br><span class="line">  <span class="attr">fallback</span>: boolean</span><br><span class="line">  <span class="attr">beforeHooks</span>: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;</span><br><span class="line">  resolveHooks: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;</span><br><span class="line">  afterHooks: <span class="built_in">Array</span>&lt;?AfterNavigationHook&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options: RouterOptions = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.apps = []</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">    <span class="built_in">this</span>.beforeHooks = []</span><br><span class="line">    <span class="built_in">this</span>.resolveHooks = []</span><br><span class="line">    <span class="built_in">this</span>.afterHooks = []</span><br><span class="line">    <span class="built_in">this</span>.matcher = createMatcher(options.routes || [], <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mode = options.mode || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.fallback = mode === <span class="string">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fallback) &#123;</span><br><span class="line">      mode = <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">      mode = <span class="string">&#x27;abstract&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="built_in">this</span>, options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="built_in">this</span>, options.base, <span class="built_in">this</span>.fallback)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="built_in">this</span>, options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  match(raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.matcher.match(raw, current, redirectedFrom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">currentRoute</span>(): ?<span class="title">Route</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.history &amp;&amp; <span class="built_in">this</span>.history.current</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params">app: any</span>)</span> &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; assert(install.installed, <span class="string">`not installed. Make sure to call \`Vue.use(VueRouter)\` `</span> + <span class="string">`before creating root instance.`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.apps.push(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.app) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.app = app</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.history</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History) &#123;</span><br><span class="line">      history.transitionTo(history.getCurrentLocation())</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">      <span class="keyword">const</span> setupHashListener = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">      &#125;</span><br><span class="line">      history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.apps.forEach(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeEach(fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerHook(<span class="built_in">this</span>.beforeHooks, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeResolve(fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerHook(<span class="built_in">this</span>.resolveHooks, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  afterEach(fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerHook(<span class="built_in">this</span>.afterHooks, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onReady</span>(<span class="params">cb: <span class="built_in">Function</span>, errorCb?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.onReady(cb, errorCb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onError</span>(<span class="params">errorCb: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.onError(errorCb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.push(location, onComplete, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.replace(location, onComplete, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.go(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">back</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.go(-<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">forward</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.go(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMatchedComponents(to?: RawLocation | Route): <span class="built_in">Array</span>&lt;any&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> route: any = to ? (to.matched ? to : <span class="built_in">this</span>.resolve(to).route) : <span class="built_in">this</span>.currentRoute</span><br><span class="line">    <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [].concat.apply(</span><br><span class="line">      [],</span><br><span class="line">      route.matched.map(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(m.components).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> m.components[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(</span><br><span class="line">    to: RawLocation,</span><br><span class="line">    current?: Route,</span><br><span class="line">    append?: boolean</span><br><span class="line">  ): &#123;</span><br><span class="line">    <span class="attr">location</span>: Location,</span><br><span class="line">    <span class="attr">route</span>: Route,</span><br><span class="line">    <span class="attr">href</span>: string,</span><br><span class="line">    <span class="attr">normalizedTo</span>: Location,</span><br><span class="line">    <span class="attr">resolved</span>: Route</span><br><span class="line">  &#125; &#123;</span><br><span class="line">    <span class="keyword">const</span> location = normalizeLocation(to, current || <span class="built_in">this</span>.history.current, append, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.match(location, current)</span><br><span class="line">    <span class="keyword">const</span> fullPath = route.redirectedFrom || route.fullPath</span><br><span class="line">    <span class="keyword">const</span> base = <span class="built_in">this</span>.history.base</span><br><span class="line">    <span class="keyword">const</span> href = createHref(base, fullPath, <span class="built_in">this</span>.mode)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      location,</span><br><span class="line">      route,</span><br><span class="line">      href,</span><br><span class="line">      <span class="attr">normalizedTo</span>: location,</span><br><span class="line">      <span class="attr">resolved</span>: route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addRoutes</span>(<span class="params">routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.matcher.addRoutes(routes)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.history.current !== START) &#123;</span><br><span class="line">      <span class="built_in">this</span>.history.transitionTo(<span class="built_in">this</span>.history.getCurrentLocation())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VueRouter 是一个类，先看构造函数做了那些事情，<code>this.app</code> 表示根 Vue 实例，<code>this.apps</code> 保存持有 <code>$options.router</code> 属性的 Vue 实例，<code>this.options</code> 保存路由配置，<code>beforeHooks,resolveHooks,afterHooks</code> 表示一些钩子，<code>this.matcher</code> 表示路由匹配器，<code>this.fallback</code>表示浏览器不支持回退到 <code>hash</code>模式，<code>this.mode</code>表示创建的模式，<code>this.history</code> 表示路由历史的具体的实现实例，不同的 <code>HTML5History,HashHistory,AbstractHistory</code> 类继承自 <code>History</code> 类</p><p>我们在实例化 <code>Vue</code> 的时候传入 <code>VueRouter</code> 的实例 <code>router</code>，组件初始化时在混入的 <code>beforeCreate</code> 钩子中，如果定义了 <code>this.$options.router</code> 就会执行 <code>this._router.init(this)</code></p><p>init 方法会把 this（vue 实例）存储在 <code>this.app</code> 中，只有根实例会存在 <code>this.app</code> 中，并且会拿当前的 <code>this.history</code> 执行 <code>history.transitionTo</code> 方法来做路由过渡</p><h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Matcher = &#123;</span><br><span class="line">  <span class="attr">match</span>: <span class="function">(<span class="params">raw: RawLocation, current?: Route, redirectedFrom?: Location</span>) =&gt;</span> Route,</span><br><span class="line">  <span class="attr">addRoutes</span>: <span class="function">(<span class="params">routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中涉及到了两个概念，<code>Location</code> 和 <code>Route</code>，可以发现 <code>Location</code> 基本和 <code>window.location</code> 是同样的意思，都是对 url 的结构化描述，<code>Route</code> 有了 <code>fullPath matched redirectedFrom meta</code> 等特有属性，他是路由中的一条线路</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare type Location = &#123;</span><br><span class="line">  _normalized?: boolean,</span><br><span class="line">  name?: string,</span><br><span class="line">  path?: string,</span><br><span class="line">  hash?: string,</span><br><span class="line">  query?: Dictionary&lt;string&gt;,</span><br><span class="line">  params?: Dictionary&lt;string&gt;,</span><br><span class="line">  append?: boolean,</span><br><span class="line">  replace?: boolean</span><br><span class="line">&#125;</span><br><span class="line">declare type Route = &#123;</span><br><span class="line">  <span class="attr">path</span>: string,</span><br><span class="line">  <span class="attr">name</span>: ?string,</span><br><span class="line">  <span class="attr">hash</span>: string,</span><br><span class="line">  <span class="attr">query</span>: Dictionary&lt;string&gt;,</span><br><span class="line">  params: Dictionary&lt;string&gt;,</span><br><span class="line">  fullPath: string,</span><br><span class="line">  <span class="attr">matched</span>: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  redirectedFrom?: string,</span><br><span class="line">  meta?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.matcher</code> 就是在 <code>VueRouter</code> 实例化通过 <code>createMatcher</code> 创建的, <code>createMathcer</code> 接受两个参数，一个是 <code>routes</code>，一个是 <code>router</code> 实例</p><p>createMatcher 首先执行<code>const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)</code> 创建路由映射表</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouteMap</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldPathList?: <span class="built_in">Array</span>&lt;string&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldPathMap?: Dictionary&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldNameMap?: Dictionary&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): </span>&#123;</span><br><span class="line">  <span class="attr">pathList</span>: <span class="built_in">Array</span>&lt;string&gt;,</span><br><span class="line">  pathMap: Dictionary&lt;RouteRecord&gt;,</span><br><span class="line">  nameMap: Dictionary&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="comment">// the path list is used to control path matching priority</span></span><br><span class="line">  <span class="keyword">const</span> pathList: <span class="built_in">Array</span>&lt;string&gt; = oldPathList || []</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    addRouteRecord(pathList, pathMap, nameMap, route)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ensure wildcard routes are always at the end</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = pathList.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathList[i] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      pathList.push(pathList.splice(i, <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">      l--</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pathList,</span><br><span class="line">    pathMap,</span><br><span class="line">    nameMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createRouteMap</code> 把路由映射表分成三部分，<code>pathList</code> 存储所有的 <code>path</code>，<code>pathMap</code> 表示 <code>path</code> 到 <code>routeRecord</code> 的映射关系，<code>nameMap</code> 表示 <code>name</code> 到 <code>routeRecord</code> 的映射关系</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare type RouteRecord = &#123;</span><br><span class="line">  <span class="attr">path</span>: string,</span><br><span class="line">  <span class="attr">regex</span>: RouteRegExp,</span><br><span class="line">  <span class="attr">components</span>: Dictionary&lt;any&gt;,</span><br><span class="line">  instances: Dictionary&lt;any&gt;,</span><br><span class="line">  name: ?string,</span><br><span class="line">  <span class="attr">parent</span>: ?RouteRecord,</span><br><span class="line">  <span class="attr">redirect</span>: ?RedirectOption,</span><br><span class="line">  <span class="attr">matchAs</span>: ?string,</span><br><span class="line">  <span class="attr">beforeEnter</span>: ?NavigationGuard,</span><br><span class="line">  <span class="attr">meta</span>: any,</span><br><span class="line">  <span class="attr">props</span>: boolean | <span class="built_in">Object</span> | <span class="built_in">Function</span> | Dictionary&lt;boolean | <span class="built_in">Object</span> | <span class="built_in">Function</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>routeRecord</code> 就是 <code>addRouteRecord</code> 执行生成的，它遍历 <code>routes</code> 为每一个 <code>route</code> 执行 <code>addRouteRecord</code> 生成一条记录，然后用 <code>pathList</code> <code>pathMap</code> <code>nameMap</code> 管理起来<br>创建的 routeRecord 如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> record: RouteRecord = &#123;</span><br><span class="line">  <span class="attr">path</span>: normalizedPath, <span class="comment">// cleanPath(`$&#123;parent.path&#125;/$&#123;path&#125;`)</span></span><br><span class="line">  <span class="attr">regex</span>: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><br><span class="line">  <span class="attr">components</span>: route.components || &#123; <span class="attr">default</span>: route.component &#125;,</span><br><span class="line">  <span class="attr">instances</span>: &#123;&#125;,</span><br><span class="line">  name,</span><br><span class="line">  parent,</span><br><span class="line">  matchAs,</span><br><span class="line">  <span class="attr">redirect</span>: route.redirect,</span><br><span class="line">  <span class="attr">beforeEnter</span>: route.beforeEnter,</span><br><span class="line">  <span class="attr">meta</span>: route.meta || &#123;&#125;,</span><br><span class="line">  <span class="attr">props</span>: route.props == <span class="literal">null</span> ? &#123;&#125; : route.components ? route.props : &#123; <span class="attr">default</span>: route.props &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code> 是规范化后的路径，<code>regex</code> 是一个正则的扩展 解析<code>url</code>，<code>components</code> 对应 <code>&#123;default: route.component&#125;</code>，instances 是组件实例，<code>parent</code> 是父的 <code>routeRecord</code>，因为我们一般也会配置子路由，所以 <code>RouteRecord</code> 也是一个树形结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.children) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  route.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> childMatchAs = matchAs ? cleanPath(<span class="string">`<span class="subst">$&#123;matchAs&#125;</span>/<span class="subst">$&#123;child.path&#125;</span>`</span>) : <span class="literal">undefined</span></span><br><span class="line">    addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归执行 <code>addRouteRecord</code> 的时候把当前 <code>child</code> 作为 <code>parent</code> 参数传入，这样深度遍历，我们就能拿到 <code>route</code> 的全部记录</p><p>因为 <code>pathList</code> <code>pathMap</code> <code>nameMap</code> 都是引用类型，所以我们会把所有的数据都统计到，经过 <code>createRouteMap</code> 的执行，我们会得到 <code>pathList pathMap nameMap</code>，有所有的<code>path</code>，以及对应的 <code>routeRecord</code></p><p>回到 <code>createMatcher</code>，创建完路由映射表之后，定义一些方法，最后返回 <code>&#123; match, addRoutes &#125;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span>(<span class="params">routes</span>) </span>&#123;</span><br><span class="line">  createRouteMap(routes, pathList, pathMap, nameMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addRoutes</code> 方法的作用就是动态添加路由，调用 <code>createRouteMap</code> 传入新的 <code>routes</code></p><p><code>match</code> 函数接受 3 个参数，<code>raw</code> 是 <code>rawLocation</code> 类型，它可以是一个 <code>url</code> 字符串，也可以是一个 <code>Location</code> 对象，<code>currentRoute</code> 是 <code>route</code> 类型，表示当前的路径，<code>redirectFrom</code> 和重定向相关，<br><code>match</code> 方法就是接受一个 <code>raw</code> 和当前的 <code>currentRoute</code> 计算出一个新的路径并返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location</span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(raw, currentRoute, <span class="literal">false</span>, router)</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="keyword">const</span> record = nameMap[name]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      warn(record, <span class="string">`Route with name &#x27;<span class="subst">$&#123;name&#125;</span>&#x27; does not exist`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    <span class="keyword">const</span> paramNames = record.regex.keys.filter(<span class="function"><span class="params">key</span> =&gt;</span> !key.optional).map(<span class="function"><span class="params">key</span> =&gt;</span> key.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> location.params !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      location.params = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; <span class="keyword">typeof</span> currentRoute.params === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> currentRoute.params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> location.params) &amp;&amp; paramNames.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          location.params[key] = currentRoute.params[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (record) &#123;</span><br><span class="line">      location.path = fillParams(record.path, location.params, <span class="string">`named route &quot;<span class="subst">$&#123;name&#125;</span>&quot;`</span>)</span><br><span class="line">      <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.path) &#123;</span><br><span class="line">    location.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pathList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = pathList[i]</span><br><span class="line">      <span class="keyword">const</span> record = pathMap[path]</span><br><span class="line">      <span class="keyword">if</span> (matchRoute(record.regex, location.path, location.params)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行 <code>normalizeLocation</code> 方法，根据 <code>raw</code> <code>current</code> 计算出新的 <code>location</code>，他主要处理了两种情况，一种是有 <code>params</code> 且没有 <code>path</code>，一种是有 <code>path</code> 的，对于第一种情况，如果 <code>current</code> 有 <code>name</code>, 计算出的 <code>location</code> 也有 <code>name</code>。<code>normalizeLocation</code> 返回 <code>&#123;_normalized: true, path, query, hash&#125;</code></p><p>计算出 <code>location</code> 后，对 <code>location</code> 的 <code>name</code> 和 <code>path</code> 的两种情况做了处理<br>有 <code>name</code> 情况根据 <code>nameMap</code> 匹配到 <code>record</code>，它是一个 <code>RouteRecord</code> 对象，如果 <code>record</code> 不存在，则匹配失败，返回一个空路径。然后拿到 <code>record</code> 对应的 <code>paramNames</code>，再对比 <code>currentRoute</code> 中的 <code>params</code>，把交集部分添加到 <code>location</code> 中，然后再通过 <code>fillParams</code> 方法根据 <code>record.path</code> 计算出 <code>location.path</code>，最后调用 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径</p><p>通过 <code>name</code> 我们可以很快找到 <code>record</code>，但是通过 <code>path</code> 并不能，因为我们计算后的 <code>location.path</code> 是一个真实路径，而 <code>record</code> 中的 <code>path</code> 可能会有 <code>param</code>，因此需要对所有的 <code>pathList</code> 做顺序遍历，然后通过 <code>matchRoute</code> 方法根据 <code>record.regex location.path location.params</code> 匹配，如果匹配到就通过 <code>_createRoute(record, location, redirectedFrom)</code> 去生成一条新路径。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span>(<span class="params">record: ?RouteRecord, location: Location, redirectedFrom?: Location</span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (record &amp;&amp; record.redirect) &#123;</span><br><span class="line">    <span class="keyword">return</span> redirect(record, redirectedFrom || location)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (record &amp;&amp; record.matchAs) &#123;</span><br><span class="line">    <span class="keyword">return</span> alias(record, location, record.matchAs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createRoute(record, location, redirectedFrom, router)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createRoute</code> 可以根据 <code>record</code> 和 <code>location</code> 创建出一条 <code>route</code> 路径，<code>vue-router</code> 中所有的路径都是通过 <code>createRoute</code> 函数创建，并且是 <code>freeze</code> 不可被外部修改的，<code>Route</code> 最终都会有一个特别重要的属性 <code>matched</code>，它通过 <code>formatMatch</code> 计算而来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatMatch</span>(<span class="params">record: ?RouteRecord</span>): <span class="title">Array</span>&lt;<span class="title">RouteRecord</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (record) &#123;</span><br><span class="line">    res.unshift(record)</span><br><span class="line">    record = record.parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看它通过 <code>record</code> 循环向上找 <code>parent</code>，直到找到最外层，并把所有的 <code>record</code> 都 <code>push</code> 到一个数组中，最终返回的就是 <code>record</code> 数组，它记录了一条线路上的所有 <code>record</code>，<code>matched</code> 属性非常有用，它为之后渲染组件提供了依据</p><h2 id="路径切换"><a href="#路径切换" class="headerlink" title="路径切换"></a>路径切换</h2><p>history.transitionTo 是 Vue-Router 中非常重要的方法，当我们切换路由线路的时候，就会执行该方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transitionTo (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> route = <span class="built_in">this</span>.router.match(location, <span class="built_in">this</span>.current)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.confirmTransition(route, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">    onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    <span class="built_in">this</span>.ensureURL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">      <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.readyCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123; cb(route) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">      onAbort(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; !<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">      <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.readyErrorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123; cb(err) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transitionTo 首先根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径，然后执行 confirmTransition 做真正的切换，<br>这个过程可能有一些异步的操作（异步操作），所以整个 cinfirmTransition API 设计成带有成功回调函数和失败回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">confirmTransition (route: Route, <span class="attr">onComplete</span>: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">    <span class="keyword">const</span> abort = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// changed after adding errors with</span></span><br><span class="line">      <span class="comment">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span></span><br><span class="line">      <span class="comment">// redirect and aborted navigation would produce an err == null</span></span><br><span class="line">      <span class="keyword">if</span> (!isNavigationFailure(err) &amp;&amp; isError(err)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.errorCbs.length) &#123;</span><br><span class="line">          <span class="built_in">this</span>.errorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          warn(<span class="literal">false</span>, <span class="string">&#x27;uncaught error during route navigation:&#x27;</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      onAbort &amp;&amp; onAbort(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> lastRouteIndex = route.matched.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> lastCurrentIndex = current.matched.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isSameRoute(route, current) &amp;&amp;</span><br><span class="line">      <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">      lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">      route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.ensureURL()</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">      <span class="built_in">this</span>.current.matched,</span><br><span class="line">      route.matched</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">      <span class="comment">// in-component leave guards</span></span><br><span class="line">      extractLeaveGuards(deactivated),</span><br><span class="line">      <span class="comment">// global before hooks</span></span><br><span class="line">      <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">      <span class="comment">// in-component update hooks</span></span><br><span class="line">      extractUpdateHooks(updated),</span><br><span class="line">      <span class="comment">// in-config enter guards</span></span><br><span class="line">      activated.map(<span class="function"><span class="params">m</span> =&gt;</span> m.beforeEnter),</span><br><span class="line">      <span class="comment">// async components</span></span><br><span class="line">      resolveAsyncComponents(activated)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.pending = route</span><br><span class="line">    <span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">            <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">            abort(createNavigationAbortedError(current, route))</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">            abort(to)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">            (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">              (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> to.name === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">            abort(createNavigationRedirectedError(current, route))</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">              <span class="built_in">this</span>.replace(to)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.push(to)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">            next(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        abort(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> postEnterCbs = []</span><br><span class="line">      <span class="keyword">const</span> isValid = <span class="function">() =&gt;</span> <span class="built_in">this</span>.current === route</span><br><span class="line">      <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">      <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">      <span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">      <span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">      runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">          <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">        onComplete(route)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">          <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            postEnterCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">              cb()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先定义了 <code>abort</code> 函数，然后判断如果满足计算后的 <code>route</code> 和 <code>current</code> 是相同路径的话，则直接调用 <code>this.ensureUrl</code> 和 <code>abort</code></p><p>接着根据 <code>current.matched</code> 和 <code>route.matched</code> 执行 <code>resolveQueue</code> 方法解析出 3 个队列，因为 <code>matched</code> 是一个 <code>routeRecord</code> 数组，所以遍历长度长的找到两个 <code>route</code> 不一样的位置，拿到 <code>updated</code> <code>activeted</code> <code>deactiveted</code> 三个 <code>RouteRecord</code> 数组，接下来要执行一系列的钩子</p><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>守卫就是一系列钩子<br>接下里的逻辑就是首先构造一个队列 <code>queue</code>，然后再定义一个 iterator，最后执行 <code>runQueue</code> 执行这个队列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runQueue</span>(<span class="params">queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;, fn: <span class="built_in">Function</span>, cb: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常经典的异步函数队列化执行的模式，queue 是一个 <code>NavigationGuard</code> 类型的数组，我们定义了 <code>step</code> 函数，每次根据 <code>index</code> 从 <code>queue</code> 中取出一个 <code>guard</code>，然后执行 <code>fn</code> 函数，<br>并且吧 <code>guard</code> 作为参数传入，第二个参数是一个函数，当这个函数执行的时候再递归执行 <code>step</code> 函数，前进到下一个，这里的 <code>fn</code> 就是 <code>iterator</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (to === <span class="literal">false</span> || isError(to)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(to)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> || (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> to.name === <span class="string">&#x27;string&#x27;</span>))) &#123;</span><br><span class="line">        abort()</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">          <span class="built_in">this</span>.replace(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.push(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    abort(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iterator</code> 函数就是去执行 每一个导航守卫 <code>hook</code>，并传入 <code>route</code> <code>current</code> 和匿名函数，这些参数对应文档中的 <code>to</code> <code>from</code> <code>next</code>, 如果执行了匿名函数，会根据一些条件执行 <code>abort</code> 和 <code>next</code>, 只有执行 <code>next</code> 才会进入下一个钩子。(这里的 <code>next</code> 就会调用 <code>runQueue</code> 中 <code>fn</code> 的回调)</p><p>最后看一下 这个 <code>queue</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">  extractLeaveGuards(deactivated),</span><br><span class="line">  <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">  extractUpdateHooks(updated),</span><br><span class="line">  activated.map(<span class="function"><span class="params">m</span> =&gt;</span> m.beforeEnter),</span><br><span class="line">  resolveAsyncComponents(activated)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中钩子的顺序如下：</p><ol><li>在失活的组件里调用离开守卫</li><li>调用全局的 <code>beforeEach</code> 守卫</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫</li><li>在激活的路由配置里调用 <code>beforeEnter</code></li><li>解析异步路由</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code></li><li>调用全局的 <code>beforeResolve</code> 钩子</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line"><span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br></pre></td></tr></table></figure><ol start="8"><li>调用全局的 <code>afterEach</code> 钩子</li><li>触发 <code>DOM</code> 更新</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">  <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    postEnterCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>当我们点击 <code>router-link</code> 的时候，实际上最终会执行 <code>router.push</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!onComplete &amp;&amp; !onAbort &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.history.push(location, resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.history.push(location, onComplete, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>hash</code> 模式下的 <code>history.push</code></strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>.transitionTo(</span><br><span class="line">    location,</span><br><span class="line">    <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      pushHash(route.fullPath)</span><br><span class="line">      handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;,</span><br><span class="line">    onAbort</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 transitionTo 成功的回调中，会调用 pushHash 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    pushState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>supportPushState</code> 为 <code>true</code>，就执行 <code>pushState(getUrl(path))</code>，否则直接替换 <code>window.location.hash</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">  saveScrollPosition()</span><br><span class="line">  <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      history.replaceState(&#123; <span class="attr">key</span>: _key &#125;, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _key = genKey()</span><br><span class="line">      history.pushState(&#123; <span class="attr">key</span>: _key &#125;, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pushState</code> 会调用浏览器原生的 <code>history</code> 的 <code>pushState</code> 接口或者 <code>replaceState</code> 接口，更新浏览器的 <code>url</code> 地址，并把当前 <code>url</code> 压入历史栈中</p><p>然后在 h`istory 的初始化中，会设置一个监听器，监听历史栈的变化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setupListeners () &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="built_in">this</span>.router</span><br><span class="line">  <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">  <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">    setupScroll()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(supportsPushState ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">    <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(getHash(), <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">        handleScroll(<span class="built_in">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">        replaceHash(route.fullPath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>router.init</code> 的时候，首次执行 <code>transitionTo</code> 时成功或失败的回调都会设置为 <code>setupListeners</code>, 这个函数添加 <code>popstate</code> 或者 <code>hashchange</code> 事件，<br>事件的回调会执行 <code>transitionTo</code> 并把 <code>getHash()</code> 的结果作为第一个参数. 当点击浏览器返回按钮的时候，如果已经有 <code>url</code> 被压入历史栈，则会触发 <code>popstate</code> 事件</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>路由最终的渲染离不开组件，<code>Vue-Router</code> 内置了 <code>&lt;router-view&gt;</code> 组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;RouterView&#x27;</span>,</span><br><span class="line">  <span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">_, &#123; props, children, parent, data &#125;</span>)</span> &#123;</span><br><span class="line">    data.routerView = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> h = parent.$createElement</span><br><span class="line">    <span class="keyword">const</span> name = props.name</span><br><span class="line">    <span class="keyword">const</span> route = parent.$route</span><br><span class="line">    <span class="keyword">const</span> cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">        depth++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent._inactive) &#123;</span><br><span class="line">        inactive = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    data.routerViewDepth = depth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inactive) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(cache[name], data, children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line">    <span class="keyword">if</span> (!matched) &#123;</span><br><span class="line">      cache[name] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> component = (cache[name] = matched.components[name])</span><br><span class="line"></span><br><span class="line">    data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">      <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">        matched.instances[name] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;(data.hook || (data.hook = &#123;&#125;)).prepatch = <span class="function">(<span class="params">_, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">      matched.instances[name] = vnode.componentInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> propsToPass = (data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name]))</span><br><span class="line">    <span class="keyword">if</span> (propsToPass) &#123;</span><br><span class="line">      propsToPass = data.props = extend(&#123;&#125;, propsToPass)</span><br><span class="line">      <span class="keyword">const</span> attrs = (data.attrs = data.attrs || &#123;&#125;)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsToPass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!component.props || !(key <span class="keyword">in</span> component.props)) &#123;</span><br><span class="line">          attrs[key] = propsToPass[key]</span><br><span class="line">          <span class="keyword">delete</span> propsToPass[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 是一个函数组件，它的渲染也是依赖 render 函数，我们分析一下他的渲染</p><p>首先获取 createElement name route cache 等变量</p><p>然后在 <code>router.init</code> 的时候，会执行 history.listen()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">listen (cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.cb = cb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>transitionTo</code> 成功的回调中 <code>afterEach</code> 之前会执行 <code>updateRoute</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateRoute (route: Route) &#123;</span><br><span class="line">  <span class="built_in">this</span>.current = route</span><br><span class="line">  <span class="built_in">this</span>.cb &amp;&amp; <span class="built_in">this</span>.cb(route)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$route</code> 是定义在 <code>Vue.prototype</code> 上。每个组件实例访问 <code>$route</code> 属性，就是访问根实例的 <code>_route</code>，也就是当前的路由线路。</p><p><code>&lt;router-view&gt;</code> 是支持嵌套的，回到 <code>render</code> 函数，其中定义了 <code>depth</code> 的概念，他表示 <code>router-view</code> 嵌套的深度，每个 <code>router-view</code> 在渲染的时候都会执行如下逻辑：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.routerView = <span class="literal">true</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) &#123;</span><br><span class="line">    depth++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parent._inactive) &#123;</span><br><span class="line">    inactive = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  parent = parent.$parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> component = (cache[name] = matched.components[name])</span><br></pre></td></tr></table></figure><p><code>parent._routerRoot</code> 表示的是根 <code>Vue</code> 实例，在这个过程，如果碰到了父节点也是 <code>&lt;router-view&gt;</code> 的时候，说明有嵌套的情况，<code>depth++</code>, 遍历完成后，根据当前线路匹配的路径和 <code>depth</code><br>找到对应的 <code>RouteRecord</code>，进而找到该渲染的组件。</p><p>除了找到了应该渲染的组件，还定义了一个注册路由实例的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">  <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">    matched.instances[name] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 <code>vnode</code> 的 <code>data</code> 定义了 <code>registerRouteInstance</code> 方法，调用该方法去注册路由的实例<br>在混入的 <code>beforeCreate</code> 钩子函数中，会执行 <code>registerInstance</code> 方法，进而执行 <code>render</code> 函数中定义的 <code>registerRouteInstance</code>，从而给 <code>matched.instances[name]</code> 赋值当前组件的 <code>vm</code> 实例</p><p>render 函数最后根据 component 渲染出对应的组件 vnode</p><p><strong>那么当我们执行 transitionTo 来更改路由后，组件是如何渲染的呢？</strong></p><p>在混入的 <code>beforeCreate</code> 钩子中我们吧 <code>this._route</code> 变为了响应式属性，我们在 渲染 r<code>outer-view</code> 的时候，会访问 <code>parent.$route</code>, 触发了 <code>getter</code>，相当于 <code>router-view</code> 对它有依赖，然后再执行完 <code>transitionTo</code> 后，修改 <code>app._route</code> 的时候又触发了 <code>setter</code>，因此会通知 <code>router-view</code> 的渲染 <code>watcher</code> 更新，重新渲染组件</p><p>VueRotuer 还内置了 <code>router-link</code> 组件</p><p>通过 to 属性指定目标地址，默认渲染成带有正确连接的 a 标签，可以通过 tag 生成别的标签，另外当路由成功激活时，链接元素自动设置一个表示激活的 css 类名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;RouterLink&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">to</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: toTypes,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">tag</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">exact</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="attr">append</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="attr">replace</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="attr">activeClass</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">exactActiveClass</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">event</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: eventTypes,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;click&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">h: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">this</span>.$router</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.$route</span><br><span class="line">    <span class="keyword">const</span> &#123; location, route, href &#125; = router.resolve(<span class="built_in">this</span>.to, current, <span class="built_in">this</span>.append)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> classes = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> globalActiveClass = router.options.linkActiveClass</span><br><span class="line">    <span class="keyword">const</span> globalExactActiveClass = router.options.linkExactActiveClass</span><br><span class="line">    <span class="keyword">const</span> activeClassFallback = globalActiveClass == <span class="literal">null</span> ? <span class="string">&#x27;router-link-active&#x27;</span> : globalActiveClass</span><br><span class="line">    <span class="keyword">const</span> exactActiveClassFallback = globalExactActiveClass == <span class="literal">null</span> ? <span class="string">&#x27;router-link-exact-active&#x27;</span> : globalExactActiveClass</span><br><span class="line">    <span class="keyword">const</span> activeClass = <span class="built_in">this</span>.activeClass == <span class="literal">null</span> ? activeClassFallback : <span class="built_in">this</span>.activeClass</span><br><span class="line">    <span class="keyword">const</span> exactActiveClass = <span class="built_in">this</span>.exactActiveClass == <span class="literal">null</span> ? exactActiveClassFallback : <span class="built_in">this</span>.exactActiveClass</span><br><span class="line">    <span class="keyword">const</span> compareTarget = location.path ? createRoute(<span class="literal">null</span>, location, <span class="literal">null</span>, router) : route</span><br><span class="line"></span><br><span class="line">    classes[exactActiveClass] = isSameRoute(current, compareTarget)</span><br><span class="line">    classes[activeClass] = <span class="built_in">this</span>.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.replace) &#123;</span><br><span class="line">          router.replace(location)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          router.push(location)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> on = &#123; <span class="attr">click</span>: guardEvent &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.event)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.event.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        on[e] = handler</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      on[<span class="built_in">this</span>.event] = handler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data: any = &#123;</span><br><span class="line">      <span class="attr">class</span>: classes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.tag === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">      data.on = on</span><br><span class="line">      data.attrs = &#123; href &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> a = findAnchor(<span class="built_in">this</span>.$slots.default)</span><br><span class="line">      <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        a.isStatic = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">const</span> extend = _Vue.util.extend</span><br><span class="line">        <span class="keyword">const</span> aData = (a.data = extend(&#123;&#125;, a.data))</span><br><span class="line">        aData.on = on</span><br><span class="line">        <span class="keyword">const</span> aAttrs = (a.data.attrs = extend(&#123;&#125;, a.data.attrs))</span><br><span class="line">        aAttrs.href = href</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.on = on</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h(<span class="built_in">this</span>.tag, data, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>router.resolve</code> 函数执行<br>先规范生成目标 <code>location</code>，再根据 <code>location</code> 和 <code>match</code> 通过 <code>this.match</code> 方法计算生成目标路径 <code>route</code>，然后再根据 <code>base、fullPath</code> 和 <code>this.mode</code> 通过 <code>createHref</code> 方法计算出最终跳转的 <code>href</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve (</span><br><span class="line">  to: RawLocation,</span><br><span class="line">  current?: Route,</span><br><span class="line">  append?: boolean</span><br><span class="line">): &#123;</span><br><span class="line">  <span class="attr">location</span>: Location,</span><br><span class="line">  <span class="attr">route</span>: Route,</span><br><span class="line">  <span class="attr">href</span>: string,</span><br><span class="line">  <span class="attr">normalizedTo</span>: Location,</span><br><span class="line">  <span class="attr">resolved</span>: Route</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(</span><br><span class="line">    to,</span><br><span class="line">    current || <span class="built_in">this</span>.history.current,</span><br><span class="line">    append,</span><br><span class="line">    <span class="built_in">this</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> route = <span class="built_in">this</span>.match(location, current)</span><br><span class="line">  <span class="keyword">const</span> fullPath = route.redirectedFrom || route.fullPath</span><br><span class="line">  <span class="keyword">const</span> base = <span class="built_in">this</span>.history.base</span><br><span class="line">  <span class="keyword">const</span> href = createHref(base, fullPath, <span class="built_in">this</span>.mode)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    location,</span><br><span class="line">    route,</span><br><span class="line">    href,</span><br><span class="line">    <span class="attr">normalizedTo</span>: location,</span><br><span class="line">    <span class="attr">resolved</span>: route</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHref</span> (<span class="params">base: string, fullPath: string, mode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> path = mode === <span class="string">&#x27;hash&#x27;</span> ? <span class="string">&#x27;#&#x27;</span> + fullPath : fullPath</span><br><span class="line">  <span class="keyword">return</span> base ? cleanPath(base + <span class="string">&#x27;/&#x27;</span> + path) : path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析完路由后 添加 activeClass 和 exactActiveClass</p><p>接着创建了一个守卫函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.replace) &#123;</span><br><span class="line">      router.replace(location)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (e.defaultPrevented) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (e.button !== <span class="literal">undefined</span> &amp;&amp; e.button !== <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = e.currentTarget.getAttribute(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\b_blank\b/i</span>.test(target)) <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.preventDefault) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> on = &#123; <span class="attr">click</span>: guardEvent &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.event)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.event.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    on[e] = handler</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  on[<span class="built_in">this</span>.event] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会监听点击事件或者其它可以通过 <code>prop</code> 传入的事件类型，执行 <code>hanlder</code> 函数，最终执行 <code>router.push</code> 或者 r<code>outer.replace</code> 函数</p><p>最后判断当前 <code>tag</code> 是否是 <code>&lt;a&gt;</code> 标签，<code>&lt;router-link&gt;</code> 默认会渲染成 <code>&lt;a&gt;</code> 标签，当然我们也可以修改 <code>tag</code> 的 <code>prop</code> 渲染成其他节点，这种情况下会尝试找它子元素的 <code>&lt;a&gt;</code> 标签，如果有则把事件绑定到 <code>&lt;a&gt;</code> 标签上并添加 <code>href</code> 属性，否则绑定到外层元素本身</p><p><strong>路径变化是路由中最重要的功能，我们要记住以下内容：路由始终会维护当前的线路，路由切换的时候会把当前线路切换到目标线路，切换过程中会执行一系列的导航守卫钩子函数，会更改 url，同样也会渲染对应的组件，切换完毕后会把目标线路更新替换当前线路，这样就会作为下一次的路径切换的依据。</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>路由钩子为什么要 bind</li><li>this.current 什么时候赋值</li></ol><p><code>transitionTo</code> 成功回调执行 <code>updateRoute</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateRoute (route: Route) &#123;</span><br><span class="line">  <span class="comment">//. ..</span></span><br><span class="line">  <span class="built_in">this</span>.current = route</span><br><span class="line">  <span class="built_in">this</span>.cb &amp;&amp; <span class="built_in">this</span>.cb(route)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>a 标签执行 router.push</li><li>routerRecord.instance 什么时候赋值</li></ol><p><code>beforeCreate</code> 混入了 <code>registerInstance(this, this)</code>, 这个函数会执行 <code>registerRouteInstance</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// val could be undefined for unregistration</span></span><br><span class="line">  <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">  <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">    matched.instances[name] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Vue-Router&quot;&gt;&lt;a href=&quot;#Vue-Router&quot; class=&quot;headerlink&quot; title=&quot;Vue Router&quot;&gt;&lt;/a&gt;Vue Router&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;Vue.js + Vue Router&lt;/code&gt; 创建单页只需要将组件 &lt;code&gt;components&lt;/code&gt; 映射到路由 &lt;code&gt;routes&lt;/code&gt;，然后告诉 &lt;code&gt;Vue Router&lt;/code&gt; 在哪里渲染它们&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="vue2.x" scheme="https://iiicon.github.io/blog-next/tags/vue2-x/"/>
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="vue-router" scheme="https://iiicon.github.io/blog-next/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vue3之CompositionAPI相关</title>
    <link href="https://iiicon.github.io/blog-next/2020/08/20/vue3%E4%B9%8BCompositionAPI%E7%9B%B8%E5%85%B3/"/>
    <id>https://iiicon.github.io/blog-next/2020/08/20/vue3%E4%B9%8BCompositionAPI%E7%9B%B8%E5%85%B3/</id>
    <published>2020-08-20T02:03:35.000Z</published>
    <updated>2021-12-21T06:04:02.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件渲染前的初始化过程"><a href="#组件渲染前的初始化过程" class="headerlink" title="组件渲染前的初始化过程"></a>组件渲染前的初始化过程</h1><p>Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Count is: &#123;&#123; state.count &#125;&#125;, double is: &#123;&#123; state.double &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> state = reactive(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">count</span>: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">double</span>: computed(<span class="function">() =&gt;</span> state.count * <span class="number">2</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      state.count++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      state,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      increment</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>这里的 state 和 increment 包含在 setup 函数的返回对象中，那么他是如何模板中引用的？</strong></p><p>在 <code>vue.js2.x</code> 编写组件的时候，会在 <code>props、data、methods、computed</code> 等 <code>options</code> 中定义一些变量。在组件初始化阶段，<code>vue.js</code> 内部会处理这些 <code>options</code>，即把定义的变量添加到了组件实例上。等模板编译成 <code>render</code> 函数的时候，内部通过 <code>with(this)&#123;&#125;</code> 的语法去访问在组件实例中的变量</p><p><code>vue3</code> 的 <code>setup</code> 函数的执行逻辑是在设置组件实例的时候处理的</p><h2 id="创建和设置组件实例"><a href="#创建和设置组件实例" class="headerlink" title="创建和设置组件实例"></a>创建和设置组件实例</h2><p>组件的渲染流程是 创建 <code>vnode</code> 渲染 <code>vnode</code> 和生成 <code>dom</code></p><p>其中渲染 vnode 的过程主要就是在挂载组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.component = createComponentInstance(</span><br><span class="line">    initialVNode,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense</span><br><span class="line">  ));</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  setupComponent(instance);</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看创建组件实例的过程，这个过程主要是执行了 <code>createComponentInstance</code> 创建组件实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params">vnode, parent, suspense</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> appContext =</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    <span class="comment">// 组件唯一 id</span></span><br><span class="line">    <span class="attr">uid</span>: uid++,</span><br><span class="line">    <span class="comment">// 组件 vnode</span></span><br><span class="line">    vnode,</span><br><span class="line">    <span class="comment">// 父组件实例</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// app 上下文</span></span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// vnode 节点类型</span></span><br><span class="line">    <span class="attr">type</span>: vnode.type,</span><br><span class="line">    <span class="comment">// 根组件实例</span></span><br><span class="line">    <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 新的组件 vnode</span></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 子节点 vnode</span></span><br><span class="line">    <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带副作用更新函数</span></span><br><span class="line">    <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    <span class="attr">render</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染上下文代理</span></span><br><span class="line">    <span class="attr">proxy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带有 with 区块的渲染上下文代理</span></span><br><span class="line">    <span class="attr">withProxy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 响应式相关对象</span></span><br><span class="line">    <span class="attr">effects</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 依赖注入相关</span></span><br><span class="line">    <span class="attr">provides</span>: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides),</span><br><span class="line">    <span class="comment">// 渲染代理的属性访问缓存</span></span><br><span class="line">    <span class="attr">accessCache</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染缓存</span></span><br><span class="line">    <span class="attr">renderCache</span>: [],</span><br><span class="line">    <span class="comment">// 渲染上下文</span></span><br><span class="line">    <span class="attr">ctx</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// data 数据</span></span><br><span class="line">    <span class="attr">data</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// props 数据</span></span><br><span class="line">    <span class="attr">props</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="attr">attrs</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 插槽相关</span></span><br><span class="line">    <span class="attr">slots</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// 组件或者 DOM 的 ref 引用</span></span><br><span class="line">    <span class="attr">refs</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// setup 函数返回的响应式结果</span></span><br><span class="line">    <span class="attr">setupState</span>: EMPTY_OBJ,</span><br><span class="line">    <span class="comment">// setup 函数上下文数据</span></span><br><span class="line">    <span class="attr">setupContext</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 注册的组件</span></span><br><span class="line">    <span class="attr">components</span>: <span class="built_in">Object</span>.create(appContext.components),</span><br><span class="line">    <span class="comment">// 注册的指令</span></span><br><span class="line">    <span class="attr">directives</span>: <span class="built_in">Object</span>.create(appContext.directives),</span><br><span class="line">    <span class="comment">// suspense 相关</span></span><br><span class="line">    suspense,</span><br><span class="line">    <span class="comment">// suspense 异步依赖</span></span><br><span class="line">    <span class="attr">asyncDep</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// suspense 异步依赖是否都已处理</span></span><br><span class="line">    <span class="attr">asyncResolved</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否挂载</span></span><br><span class="line">    <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否卸载</span></span><br><span class="line">    <span class="attr">isUnmounted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否激活</span></span><br><span class="line">    <span class="attr">isDeactivated</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before create</span></span><br><span class="line">    <span class="attr">bc</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，created</span></span><br><span class="line">    <span class="attr">c</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before mount</span></span><br><span class="line">    <span class="attr">bm</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，mounted</span></span><br><span class="line">    <span class="attr">m</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before update</span></span><br><span class="line">    <span class="attr">bu</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，updated</span></span><br><span class="line">    <span class="attr">u</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，unmounted</span></span><br><span class="line">    <span class="attr">um</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before unmount</span></span><br><span class="line">    <span class="attr">bum</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期, deactivated</span></span><br><span class="line">    <span class="attr">da</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 activated</span></span><br><span class="line">    <span class="attr">a</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render triggered</span></span><br><span class="line">    <span class="attr">rtg</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render tracked</span></span><br><span class="line">    <span class="attr">rtc</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 error captured</span></span><br><span class="line">    <span class="attr">ec</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 派发事件方法</span></span><br><span class="line">    <span class="attr">emit</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化渲染上下文</span></span><br><span class="line">  instance.ctx = &#123; <span class="attr">_</span>: instance &#125;;</span><br><span class="line">  <span class="comment">// 初始化根组件指针</span></span><br><span class="line">  instance.root = parent ? parent.root : instance;</span><br><span class="line">  <span class="comment">// 初始化派发事件方法</span></span><br><span class="line">  instance.emit = emit.bind(<span class="literal">null</span>, instance);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vue2</code> 通过 <code>new Vue</code>来初始化一个组件实例，到了 <code>vue3</code> 我们直接通过创建对象去创建组件的实例，这两种方法并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境</p><p>创建好 <code>instance</code> 实例后，接下来就是设置它的一些属性，目前已完成了组件的上下文，根组件指针以及派发事件方法的设置</p><p>接着是组件实例的设置流程，对 <code>setup</code> 函数的处理就在这里完成，主要就是执行 <code>setComponent</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span>(<span class="params">instance, isSSR = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props, children, shapeFlag &#125; = instance.vnode;</span><br><span class="line">  <span class="comment">// 判断是否是一个有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = shapeFlag &amp; <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR);</span><br><span class="line">  <span class="comment">// 初始化 插槽</span></span><br><span class="line">  initSlots(instance, children);</span><br><span class="line">  <span class="comment">// 设置有状态的组件实例</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> setupResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从组件 <code>vnode</code> 中获取了 <code>props</code> <code>children</code> <code>shapeFlag</code> 等属性，然后分别对 <code>props</code> 和插槽进行初始化，然后根据 <code>shapeFlag</code> 的值，我们判断如果是一个有状态的组件，就要去设置<br>执行 <code>setupStatefulComponent</code> 函数，它主要做了三件事，创建渲染上下文代理、判断处理 setup 函数、完成组件实例设置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span>(<span class="params">instance, isSSR</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type;</span><br><span class="line">  <span class="comment">// 创建渲染代理的属性访问缓存</span></span><br><span class="line">  instance.accessCache = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 创建渲染上下文代理</span></span><br><span class="line">  instance.proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, PublicInstanceProxyHandlers);</span><br><span class="line">  <span class="comment">// 判断处理 setup 函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component;</span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 执行 setup 函数，获取结果</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>,</span><br><span class="line">      [instance.props, setupContext]</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">    handleSetupResult(instance, setupResult);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 完成组件实例设置</span></span><br><span class="line">    finishComponentSetup(instance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建渲染上下文代理"><a href="#创建渲染上下文代理" class="headerlink" title="创建渲染上下文代理"></a>创建渲染上下文代理</h3><p>这一步就是对 <code>instance.ctx</code> 做了代理</p><p><code>vue2</code> 在初始化组件的时候，<code>data</code> 中定义的 <code>msg</code> 在组件内部是存储在 <code>this._data</code> 上的，而模板渲染的时候访问 <code>this.msg</code> 实际上是访问 <code>this._data.msg</code>，这是因为访问 <code>data</code> 的时候做了一层代理</p><p><code>vue3</code> 为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 <code>setupState</code> <code>ctx</code> <code>data</code> <code>props</code> 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 <code>instance.ctx</code>，所以这里的代理就是对渲染上下文 <code>instance.ctx</code> 属性的访问和修改，代理到对 <code>setupState</code> <code>ctx</code> <code>data</code> <code>props</code> 中的数据的访问和修改</p><p>接下了分析一下 proxy 的几个方法 get has set</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">&#123; _: instance &#125;, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      ctx,</span><br><span class="line">      setupState,</span><br><span class="line">      data,</span><br><span class="line">      props,</span><br><span class="line">      accessCache,</span><br><span class="line">      type,</span><br><span class="line">      appContext,</span><br><span class="line">    &#125; = instance;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">&quot;$&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// setupState / data / props / ctx</span></span><br><span class="line">      <span class="comment">// 渲染代理的属性访问缓存中</span></span><br><span class="line">      <span class="keyword">const</span> n = accessCache[key];</span><br><span class="line">      <span class="keyword">if</span> (n !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 从缓存中取</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> <span class="comment">/* SETUP */</span>:</span><br><span class="line">            <span class="keyword">return</span> setupState[key];</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> <span class="comment">/* DATA */</span>:</span><br><span class="line">            <span class="keyword">return</span> data[key];</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span> <span class="comment">/* CONTEXT */</span>:</span><br><span class="line">            <span class="keyword">return</span> ctx[key];</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span> <span class="comment">/* PROPS */</span>:</span><br><span class="line">            <span class="keyword">return</span> props[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从 setupState 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> setupState[key];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从 data 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        type.props &amp;&amp;</span><br><span class="line">        hasOwn(normalizePropsOptions(type.props)[<span class="number">0</span>], key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 从 props 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> props[key];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 从 ctx 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> ctx[key];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 都取不到</span></span><br><span class="line">        accessCache[key] = <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> publicGetter = publicPropertiesMap[key];</span><br><span class="line">    <span class="keyword">let</span> cssModule, globalProperties;</span><br><span class="line">    <span class="comment">// 公开的 $xxx 属性或方法</span></span><br><span class="line">    <span class="keyword">if</span> (publicGetter) &#123;</span><br><span class="line">      <span class="keyword">return</span> publicGetter(instance);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// css 模块，通过 vue-loader 编译的时候注入</span></span><br><span class="line">      (cssModule = type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> cssModule;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      <span class="comment">// 用户自定义的属性，也用 `$` 开头</span></span><br><span class="line">      accessCache[key] = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">return</span> ctx[key];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 全局定义的属性</span></span><br><span class="line">      ((globalProperties = appContext.config.globalProperties),</span><br><span class="line">      hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> globalProperties[key];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">      currentRenderingInstance &amp;&amp;</span><br><span class="line">      key.indexOf(<span class="string">&quot;__v&quot;</span>) !== <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; key[<span class="number">0</span>] === <span class="string">&quot;$&quot;</span> &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        <span class="comment">// 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span></span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(</span></span></span><br><span class="line"><span class="subst"><span class="string">            key</span></span></span><br><span class="line"><span class="subst"><span class="string">          )&#125;</span> must be accessed via $data because it starts with a reserved `</span> +</span><br><span class="line">            <span class="string">`character and is not proxied on the render context.`</span></span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在模板中使用的变量如果没有定义，报警告</span></span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> was accessed during render `</span> +</span><br><span class="line">            <span class="string">`but is not defined on instance.`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，函数首先判断 <code>key</code> 不以 <code>$</code> 开头的情况，这部分数据可能是 <code>setupState</code> <code>data</code> <code>props</code> <code>ctx</code> 中的一种，其中 <code>data</code> <code>props</code> 我们已经很熟悉了，<code>setupState</code> 就是 <code>setup</code> 函数返回的数据，<code>ctx</code> 包括了计算属性，组件方法和用户自定义的一些数据</p><p>如果 <code>key</code> 不以 <code>$</code> 开头，那么就依次判断 <code>setupState data props ctx</code> 中是否包含这个 <code>key</code>，如果包含就返回对应值</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">&#123; _: instance &#125;, key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, setupState, ctx &#125; = instance;</span><br><span class="line">    <span class="keyword">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 setupState 赋值</span></span><br><span class="line">      setupState[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 data 赋值</span></span><br><span class="line">      data[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key <span class="keyword">in</span> instance.props) &#123;</span><br><span class="line">      <span class="comment">// 不能直接给 props 赋值</span></span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Attempting to mutate prop &quot;<span class="subst">$&#123;key&#125;</span>&quot;. Props are readonly.`</span>,</span><br><span class="line">          instance</span><br><span class="line">        );</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&quot;$&quot;</span> &amp;&amp; key.slice(<span class="number">1</span>) <span class="keyword">in</span> instance) &#123;</span><br><span class="line">      <span class="comment">// 不能给 Vue 内部以 $ 开头的保留属性赋值</span></span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Attempting to mutate public property &quot;<span class="subst">$&#123;key&#125;</span>&quot;. `</span> +</span><br><span class="line">            <span class="string">`Properties starting with $ are reserved and readonly.`</span>,</span><br><span class="line">          instance</span><br><span class="line">        );</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用户自定义数据赋值</span></span><br><span class="line">      ctx[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>set</code> 函数主要做的事情就是对渲染上下文 <code>instance.ctx</code> 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 <code>get</code> 一样，优先判断 <code>setupState</code>，然后是 <code>data</code>，接着是 <code>props</code></p><h4 id="has"><a href="#has" class="headerlink" title="has"></a>has</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PublicInstanceProxyHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">&#123; _: &#123; data, setupState, accessCache, ctx, type, appContext &#125; &#125;, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 依次判断</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      accessCache[key] !== <span class="literal">undefined</span> ||</span><br><span class="line">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><br><span class="line">      (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) ||</span><br><span class="line">      (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[<span class="number">0</span>], key)) ||</span><br><span class="line">      hasOwn(ctx, key) ||</span><br><span class="line">      hasOwn(publicPropertiesMap, key) ||</span><br><span class="line">      hasOwn(appContext.config.globalProperties, key)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，依次判断 <code>key</code> 是否存在于 <code>accessCache、data、setupState、props</code> 、用户数据、公开属性以及全局属性中，然后返回结果。</p><h3 id="判断处理-setup-函数"><a href="#判断处理-setup-函数" class="headerlink" title="判断处理 setup 函数"></a>判断处理 setup 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断处理 setup 函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; setup &#125; = Component;</span><br><span class="line"><span class="keyword">if</span> (setup) &#123;</span><br><span class="line">  <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">  <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">    setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 执行 setup 函数获取结果</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">    setup,</span><br><span class="line">    instance,</span><br><span class="line">    <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>,</span><br><span class="line">    [instance.props, setupContext]</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">  handleSetupResult(instance, setupResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果组件中定义了 <code>setup</code> 函数，接下来就是处理 <code>setup</code> 函数的流程，主要是三个步骤：创建 <code>setup</code> 函数上下文，执行 <code>setup</code> 函数并获取结果和处理 <code>setup</code> 函数的执行结果</p><p>首先判断 setup 函数的参数长度，如果大于 1，就创建 setupContext 上下文</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">  setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetupContext</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">attrs</span>: instance.attrs,</span><br><span class="line">    <span class="attr">slots</span>: instance.slots,</span><br><span class="line">    <span class="attr">emit</span>: instance.emit,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>Toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">msg</span>: <span class="built_in">String</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    setup (props, &#123; emit &#125;) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">onClick</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        emit(<span class="string">&#x27;toggle&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        onClick</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">HelloWorld</span> @<span class="attr">toggle</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123; HelloWorld &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    setup () &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> msg = ref(<span class="string">&#x27;Hello World&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="keyword">function</span> <span class="title">toggle</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        msg.value = msg.value === <span class="string">&#x27;Hello World&#x27;</span> ? <span class="string">&#x27;Hello Vue&#x27;</span> : <span class="string">&#x27;Hello World&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        toggle,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        msg</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看出 <code>setupContext</code> 对应的就是 <code>setup</code> 函数第二个参数，接下来看一下 <code>setup</code> 函数时如何执行的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callWithErrorHandling</span> (<span class="params">fn, instance, type, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? fn(...args) : fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    handleError(err, instance, type)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callWithErrorHandling</code> 对 <code>fn</code> 做了一层包装，内部执行 <code>fn</code>，所以 <code>setup</code> 函数的第一个参数是 <code>instance.props</code> 第二个参数是 <code>setupContext</code></p><p>执行 <code>setup</code> 函数并拿到了返回的结果，那么接下来就是要用 <code>handleSetupResult</code> 函数来处理结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleSetupResult(instance, setupResult)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params">instance, setupResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// setup 返回渲染函数</span></span><br><span class="line">    instance.render = setupResult</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// 把 setup 返回结果变成响应式</span></span><br><span class="line">    instance.setupState = reactive(setupResult)</span><br><span class="line">  &#125;</span><br><span class="line">  finishComponentSetup(instance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>setupResult</code> 是一个对象的时候，我们把它变成了响应式并赋值给 <code>instance.setupState</code>，这样在模板渲染的时候，依据前面的代理规则，<code>instance.ctx</code> 就可以从 <code>instance.setupState</code> 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系</p><p>如果返回的是一个函数的话, 这个函数会作为组件的渲染函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup (props, &#123; emit &#125;) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">onClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        emit(<span class="string">&#x27;toggle&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          h(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, ctx.msg),</span><br><span class="line">          h(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">onClick</span>: onClick &#125;, <span class="string">&#x27;Toggle&#x27;</span>)</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最后就是执行 finishComponentSetup 完成组件实例的设置</p><h3 id="完成组件实例设置"><a href="#完成组件实例设置" class="headerlink" title="完成组件实例设置"></a>完成组件实例设置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span> (<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type</span><br><span class="line">  <span class="comment">// 对模板或者渲染函数的标准化</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.render) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compile &amp;&amp; Component.template &amp;&amp; !Component.render) &#123;</span><br><span class="line">      <span class="comment">// 运行时编译</span></span><br><span class="line">      Component.render = compile(Component.template, &#123;</span><br><span class="line">        <span class="attr">isCustomElement</span>: instance.appContext.config.isCustomElement || NO</span><br><span class="line">      &#125;)</span><br><span class="line">      Component.render._rc = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; !Component.render) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!compile &amp;&amp; Component.template) &#123;</span><br><span class="line">        <span class="comment">// 只编写了 template 但使用了 runtime-only 的版本</span></span><br><span class="line">        warn(<span class="string">`Component provided template option but `</span> +</span><br><span class="line">          <span class="string">`runtime compilation is not supported in this build of Vue.`</span> +</span><br><span class="line">          (<span class="string">` Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.`</span></span><br><span class="line">          ) <span class="comment">/* should not happen */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 既没有写 render 函数，也没有写 template 模板</span></span><br><span class="line">        warn(<span class="string">`Component is missing template or render function.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件对象的 render 函数赋值给 instance</span></span><br><span class="line">    instance.render = (Component.render || NOOP)</span><br><span class="line">    <span class="keyword">if</span> (instance.render._rc) &#123;</span><br><span class="line">      <span class="comment">// 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理</span></span><br><span class="line">      instance.withProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 兼容 Vue.js 2.x Options API</span></span><br><span class="line">  &#123;</span><br><span class="line">    currentInstance = instance</span><br><span class="line">    applyOptions(instance, Component)</span><br><span class="line">    currentInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vue3</code> 依然支持 <code>vue2</code> 的 <code>options API</code>，这主要就是通过 <code>applyOptions</code> 方法实现的............................</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组件渲染前的初始化过程&quot;&gt;&lt;a href=&quot;#组件渲染前的初始化过程&quot; class=&quot;headerlink&quot; title=&quot;组件渲染前的初始化过程&quot;&gt;&lt;/a&gt;组件渲染前的初始化过程&lt;/h1&gt;&lt;p&gt;Vue.js 3.0 允许我们在编写组件的时候添加一个 setup </summary>
      
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="vue3" scheme="https://iiicon.github.io/blog-next/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>vue3 组件核心源码阅读笔记</title>
    <link href="https://iiicon.github.io/blog-next/2020/08/20/vue3%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://iiicon.github.io/blog-next/2020/08/20/vue3%E7%BB%84%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-20T02:03:35.000Z</published>
    <updated>2021-12-21T06:04:02.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-的优化"><a href="#Vue-js-的优化" class="headerlink" title="Vue.js 的优化"></a>Vue.js 的优化</h1><p>Vue 3.0 从源码、性能和语法 API 三个大的方面优化了框架，也提高了开发人员的开发体验，相比于 2.x 有了很大的一个改变</p><a id="more"></a><h2 id="源码优化"><a href="#源码优化" class="headerlink" title="源码优化"></a>源码优化</h2><ul><li>更好的代码管理方式：monorepo</li><li>有类型的 JavaScript：TypeScript</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li><p>源码体积优化</p><ul><li>首先，移除一些冷门的 feature（比如 filter、inline-template 等）</li><li>其次，引入 tree-shaking 的技术，减少打包体积</li></ul></li><li><p>数据劫持优化</p></li><li><p>编译优化，借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破</p></li></ul><h2 id="语法-API-优化：Composition-API"><a href="#语法-API-优化：Composition-API" class="headerlink" title="语法 API 优化：Composition API"></a>语法 API 优化：Composition API</h2><ol><li>优化逻辑组织</li><li>优化逻辑复用</li></ol><h2 id="引入-RFC：使每个版本改动可控"><a href="#引入-RFC：使每个版本改动可控" class="headerlink" title="引入 RFC：使每个版本改动可控"></a>引入 RFC：使每个版本改动可控</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JmY3MvcHVsbHM/cT1pczpwcitpczptZXJnZWQrbGFiZWw6My54">Vue.js-RFC<i class="fa fa-external-link-alt"></i></span></p><h1 id="组件的实现：Vue-核心的实现"><a href="#组件的实现：Vue-核心的实现" class="headerlink" title="组件的实现：Vue 核心的实现"></a>组件的实现：Vue 核心的实现</h1><blockquote><p>模板 + 对象描述 + 数据 = 组件</p></blockquote><h2 id="vnode-到真实-DOM-是如何转变的？"><a href="#vnode-到真实-DOM-是如何转变的？" class="headerlink" title="vnode 到真实 DOM 是如何转变的？"></a>vnode 到真实 DOM 是如何转变的？</h2><blockquote><p>创建 vnode + 渲染 vnode + 生成 DOM</p></blockquote><h3 id="vue-初始化"><a href="#vue-初始化" class="headerlink" title="vue 初始化"></a>vue 初始化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Vue.js 3.0 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./app&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.mount(<span class="string">&quot;#app&quot;</span>); <span class="comment">// 把 App 组件挂载到 id 为 app 的 DOM 节点上</span></span><br></pre></td></tr></table></figure><p>这其中导入了一个 createApp 入口函数，他是 Vue.js 对外暴露的一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 app 对象</span></span><br><span class="line">  <span class="keyword">const</span> app = ensureRenderer().createApp(...args);</span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app;</span><br><span class="line">  <span class="comment">// 重写 mount 方法</span></span><br><span class="line">  app.mount = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码中可以看出 createApp 主要做了两件事情，创建 app 对象和重写 app.mount 方法</p><h4 id="1-创建-app-对象"><a href="#1-创建-app-对象" class="headerlink" title="1. 创建 app 对象"></a>1. 创建 app 对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = ensureRenderer().createApp(...args);</span><br></pre></td></tr></table></figure><p>其中 ensureRenderer() 用来创建一个渲染器对象，它的内部实现如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法</span></span><br><span class="line"><span class="keyword">const</span> rendererOptions = &#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  ...nodeOps,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> renderer || (renderer = createRenderer(rendererOptions));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer(options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 组件渲染的核心逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    <span class="attr">createApp</span>: createAppAPI(render),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>(<span class="params">render</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createApp createApp 方法接受的两个参数：根组件的对象和 prop</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = &#123;</span><br><span class="line">      <span class="attr">_component</span>: rootComponent,</span><br><span class="line">      <span class="attr">_props</span>: rootProps,</span><br><span class="line">      <span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps);</span><br><span class="line">        <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line">        render(vnode, rootContainer);</span><br><span class="line">        app._container = rootContainer;</span><br><span class="line">        <span class="keyword">return</span> vnode.component.proxy;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重写-app-mount-方法"><a href="#2-重写-app-mount-方法" class="headerlink" title="2. 重写 app.mount 方法"></a>2. 重写 app.mount 方法</h4><p>Vue.js 不仅仅是为 Web 平台服务，它的目标是支持跨平台渲染，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mount</span>(<span class="params">rootContainer</span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line"> <span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps)</span><br><span class="line"> <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line"> render(vnode, rootContainer)</span><br><span class="line"> app._container = rootContainer</span><br><span class="line"> <span class="keyword">return</span> vnode.component.proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的跨平台渲染流程是先创建 vnode，再渲染 vnode。此外参数 rootContainer 也可以是不同类型的值，也就是这里是通用的渲染逻辑，<br>接下来完善 Web 平台下的渲染逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.mount = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 标准化容器</span></span><br><span class="line">  <span class="keyword">const</span> container = normalizeContainer(containerOrSelector);</span><br><span class="line">  <span class="keyword">if</span> (!container) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> component = app._component;</span><br><span class="line">  <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">  <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">    component.template = container.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载前清空容器内容</span></span><br><span class="line">  container.innerHTML = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 真正的挂载</span></span><br><span class="line">  <span class="keyword">return</span> mount(container);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>app.mount 就是 重写的 mount 方法，传入 container 参数，先标准化容器，然后取出 rootComponent，<br>如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容，<br>在挂载前清空容器内容，然后执行通用的 mount 方法</p><h3 id="核心渲染流程：创建-vnode-和渲染-vnode"><a href="#核心渲染流程：创建-vnode-和渲染-vnode" class="headerlink" title="核心渲染流程：创建 vnode 和渲染 vnode"></a>核心渲染流程：创建 vnode 和渲染 vnode</h3><h4 id="创建-vnode"><a href="#创建-vnode" class="headerlink" title="创建 vnode"></a>创建 vnode</h4><p>组件 vnode 其实是对抽象事物的描述，这是因为我们并不会在页面上真正渲染一个 <code>&lt;custom-component&gt;</code> 标签，而是渲染组件内部定义的 HTML 标签。<br>vnode 有组件 vnode，普通元素 vnode，注释 vnode，文本 vnode</p><p><strong>为什么要设计 vnode？</strong></p><ul><li>抽象</li><li>跨平台都可以用</li></ul><p>回顾 app.mount 内部实现，用 createVnode 创建了根组件的 vnode</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = createVNode(rootComponent, rootProps);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">type, props = <span class="literal">null</span>, children = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props 相关逻辑，标准化 class 和 style</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 vnode 类型信息编码</span></span><br><span class="line">  <span class="keyword">const</span> shapeFlag = isString(type)</span><br><span class="line">    ? <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">    : isSuspense(type)</span><br><span class="line">    ? <span class="number">128</span> <span class="comment">/* SUSPENSE */</span></span><br><span class="line">    : isTeleport(type)</span><br><span class="line">    ? <span class="number">64</span> <span class="comment">/* TELEPORT */</span></span><br><span class="line">    : isObject(type)</span><br><span class="line">    ? <span class="number">4</span> <span class="comment">/* STATEFUL_COMPONENT */</span></span><br><span class="line">    : isFunction(type)</span><br><span class="line">    ? <span class="number">2</span> <span class="comment">/* FUNCTIONAL_COMPONENT */</span></span><br><span class="line">    : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    <span class="comment">// 一些其他属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 标准化子节点，把不同数据类型的 children 转成数组或者文本类型</span></span><br><span class="line">  normalizeChildren(vnode, children);</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 createVnode 就是对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children，返回 vnode</p><h4 id="渲染-vnode"><a href="#渲染-vnode" class="headerlink" title="渲染 vnode"></a>渲染 vnode</h4><p>在 app.mount 内部通过 render(vnode, rootContainer) 去渲染组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render(vnode, rootContainer);</span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁组件</span></span><br><span class="line">    <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">      unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或者更新组件</span></span><br><span class="line">    patch(container._vnode || <span class="literal">null</span>, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 vnode 判断去执行卸载还是创建或更新，接下来看 patch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1);</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    n1 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Text:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Comment:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Static:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们重点关注对组件的处理和对普通 dom 元素的处理<br>先看对组件的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">    mountComponent(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新组件</span></span><br><span class="line">    updateComponent(n1, n2, parentComponent, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mountComponent 就做三件事情</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.component = createComponentInstance(</span><br><span class="line">    initialVNode,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense</span><br><span class="line">  ));</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  setupComponent(instance);</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组件的创建不像 2.0 去实例化组件，内部通过返回对象创建，接着是设置组件实例，保留了很多组件相关的数据，维护了组件的上下文，包括对 props，插槽，以及其他实例的属性的初始化处理，最后是运行带副作用的渲染函数 <code>setupRenderEffect</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件生成子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance));</span><br><span class="line">      <span class="comment">// 把子树 vnode 挂载到 container 中</span></span><br><span class="line">      patch(<span class="literal">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG);</span><br><span class="line">      <span class="comment">// 保留渲染生成的子树根 DOM 节点</span></span><br><span class="line">      initialVNode.el = subTree.el;</span><br><span class="line">      instance.isMounted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该函数利用响应式库的 <code>effect</code> 函数创建了一个副作用渲染函数 <code>componentEffect</code>，当组件的数据发生变化时，<code>effect</code> 函数包裹的内部渲染函数 <code>componentEffect</code> 会重新执行一遍，从而达到重新渲染组件的目的。</p><p>先分析初始渲染</p><p><strong>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中</strong></p><p><code>initialVnode</code> 就是 <code>组件 vnode</code>，<code>subTree</code> 就是 <code>子树 vnode</code> 执行 <code>renderComponentRoot</code> 生成</p><p>我们知道每个组件都会有对应的 <code>render</code> 函数，即使你写 <code>template</code>，也会编译成 <code>render</code> 函数，而 <code>renderComponentRoot</code> 函数就是去执行 <code>render</code> 函数创建整个组件树内部的 <code>vnode</code>，把这个 <code>vnode</code> 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode。</p><p>渲染成子树 <code>vnode</code> 后，接下来就是继续调用 <code>patch</code> 函数把子树 <code>vnode</code> 挂载到 <code>container</code> 中</p><p>又回到 <code>patch</code> 函数，会继续对这个子树的 <code>vnode</code> 类型进行判断，如果是 <code>div</code> 就对应的是 <code>普通元素 vnode</code>，<br>就会处理普通 dom 执行 <code>processElement</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">&quot;svg&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    mountElement(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来看 mountElement 的逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mountElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode;</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is);</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isReservedProp(key)) &#123;</span><br><span class="line">        hostPatchProp(el, key, <span class="literal">null</span>, props[key], isSVG);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    hostSetElementText(el, vnode.children);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况 循环执行 child patch</span></span><br><span class="line">    mountChildren(</span><br><span class="line">      vnode.children,</span><br><span class="line">      el,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG &amp;&amp; type !== <span class="string">&quot;foreignObject&quot;</span>,</span><br><span class="line">      optimized || !!vnode.dynamicChildren</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  hostInsert(el, container, anchor);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，挂载元素函数主要做四件事情，创建 <code>DOM</code> 元素节点，处理 <code>props</code>，处理 <code>children</code>，挂载 <code>DOM</code> 到 container 上</p><p>渲染完 <code>subTree</code> 之后，就会执行 <code>componentEffect</code> 函数中的剩余逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initialVNode.el = subTree.el;</span><br><span class="line">instance.isMounted = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="组件更新：完整的-DOM-diff-流程是怎样的？（上）"><a href="#组件更新：完整的-DOM-diff-流程是怎样的？（上）" class="headerlink" title="组件更新：完整的 DOM diff 流程是怎样的？（上）"></a>组件更新：完整的 DOM diff 流程是怎样的？（上）</h2><h3 id="副作用渲染函数更新组件的过程"><a href="#副作用渲染函数更新组件的过程" class="headerlink" title="副作用渲染函数更新组件的过程"></a>副作用渲染函数更新组件的过程</h3><p>带副作用的渲染函数 <code>setupRenderEffect</code> 会在 instance.update 上挂载 <code>componentEffect</code> 函数，数据变化后就会执行该函数的 <code>else</code> 逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  instance,</span></span></span><br><span class="line"><span class="params"><span class="function">  initialVNode,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, vnode &#125; = instance;</span><br><span class="line">      <span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">        updateComponentPreRender(instance, next, optimized);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = vnode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 渲染新的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> nextTree = renderComponentRoot(instance);</span><br><span class="line">      <span class="comment">// 缓存旧的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.subTree;</span><br><span class="line">      <span class="comment">// 更新子树 vnode</span></span><br><span class="line">      instance.subTree = nextTree;</span><br><span class="line">      <span class="comment">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch</span></span><br><span class="line">      patch(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        <span class="comment">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点</span></span><br><span class="line">        hostParentNode(prevTree.el),</span><br><span class="line">        <span class="comment">// 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点</span></span><br><span class="line">        getNextHostNode(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 缓存更新后的 DOM 节点</span></span><br><span class="line">      next.el = nextTree.el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，更新组件主要做三件事情：更新组件 <code>vnode</code> 节点，渲染新的子树 <code>vnode</code> 根据新旧子树 <code>vnode</code> 执行 <code>patch</code> 逻辑</p><p>更新组件 <code>vnode</code> 的时候，要判断有没有新组件 <code>vnode</code> <code>next</code>，有则更新，没有就用之前的 <code>vnode</code><br>渲染新的子树 <code>vnode</code> 和之前的一样<br>最后就是核心的 <code>patch</code> 逻辑，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM</p><h3 id="核心-patch"><a href="#核心-patch" class="headerlink" title="核心 patch"></a>核心 patch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">    anchor = getNextHostNode(n1);</span><br><span class="line">    unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// n1 设置为 null 保证后续都走 mount 逻辑</span></span><br><span class="line">    n1 = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Text:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Comment:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Static:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        processElement(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        processComponent(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameVNodeType</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// n1 和 n2 节点的 type 和 key 都相同，才是相同节点</span></span><br><span class="line">  <span class="keyword">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，首先判断新旧节点是否是相同的 <code>vnode</code> 类型，如果不同，比如一个 <code>div</code> 更新成一个 <code>ul</code>，那么最简单的操作就是删除旧的 <code>div</code> 节点，再去挂载新的 <code>ul</code> 节点</p><p>如果是相同的 <code>vnode</code>，那就要走 <code>diff</code> 更新流程了，接着会根据不同的 <code>vnode</code> 类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程</p><h4 id="处理组件"><a href="#处理组件" class="headerlink" title="处理组件"></a>处理组件</h4><p>如何处理组件的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an app.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">msg</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="title">toggle</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.msg = <span class="built_in">this</span>.msg ==== <span class="string">&#x27;Vue&#x27;</span>? <span class="string">&#x27;World&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">msg</span>: <span class="built_in">String</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的 msg，并且会触发 App 组件的重新渲染</p><p>结合前面对渲染流程的分析，这里的 App 组件的根节点是 div，重新渲染的子树 vnode 节点是一个普通元素的 vnode，应该先走 processElement 逻辑，组件的更新最终还是要转换成真实的 DOM 更新<br>而实际上普通元素的处理才是 DOM 的更新<br>和渲染流程相似，更新过程也是一个树的深度优先遍历的过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到 hello 这个 组件 vnode 节点，就会执行到 processComponent 的处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processComponent = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新子组件</span></span><br><span class="line">    updateComponent(n1, n2, parentComponent, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> updateComponent = <span class="function">(<span class="params">n1, n2, parentComponent, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = (n2.component = n1.component);</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">  <span class="keyword">if</span> (shouldUpdateComponent(n1, n2, parentComponent, optimized)) &#123;</span><br><span class="line">    <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">    instance.next = n2;</span><br><span class="line">    <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    invalidateJob(instance.update);</span><br><span class="line">    <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">    instance.update();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要更新，只复制属性</span></span><br><span class="line">    n2.component = n1.component;</span><br><span class="line">    n2.el = n1.el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到， <code>processComponent</code> 通过 <code>updateComponent</code> 函数来更新组件，<code>updateComponent</code> 函数在更新子组件的时候，会先执行 <code>shouldUpdateComponent</code> 函数，根据新旧子组件 <code>vnode</code> 来判断是否需要更新子组件<br>如果 <code>shouldUpdateComponent</code> 返回 true， 那么在它的最后先执行<code> invalidateJob（instance.update）</code>避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数 <code>instance.update</code> 来主动触发子组件的更新</p><p>然后再到 <code>setupRenderEffect</code> 函数的 <code>update</code> 逻辑</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新组件</span></span><br><span class="line"><span class="keyword">let</span> &#123; next, vnode &#125; = instance;</span><br><span class="line"><span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line"><span class="keyword">if</span> (next) &#123;</span><br><span class="line">  <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">  updateComponentPreRender(instance, next, optimized);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  next = vnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> updateComponentPreRender = <span class="function">(<span class="params">instance, nextVNode, optimized</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.component = instance;</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.vnode.props;</span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.vnode = nextVNode;</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  updateProps(instance, nextVNode.props, prevProps, optimized);</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  updateSlots(instance, nextVNode.children);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合上面的代码，我们在更新组件的 <code>DOM</code> 前，需要先更新组件 <code>vnode</code> 节点信息，包括更改组件实例的 <code>vnode</code> 指针、更新 <code>props</code> 和更新插槽等一系列操作，因为组件在稍后执行 <code>renderComponentRoot</code> 时会重新渲染新的子树 <code>vnode</code> ，它依赖了更新后的组件 <code>vnode</code> 中的 <code>props</code> 和 <code>slots</code> 等数据。</p><p>所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下 <code>next</code> 是 <code>null</code>；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下 <code>next</code> 就是新的子组件 <code>vnode</code></p><p>所以 <code>processComponent</code> 处理组件 <code>vnode</code>，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些 <code>vnode</code> 的属性，并让子组件实例保留对组件 <code>vnode</code> 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 <code>vnode</code></p><p>前面也说过，组件是抽象的，组件的更新最终还是会落到对普通 <code>DOM</code> 元素的更新。所以接下来我们详细分析一下组件更新中对普通元素的处理流程</p><h4 id="处理普通元素"><a href="#处理普通元素" class="headerlink" title="处理普通元素"></a>处理普通元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  isSVG = isSVG || n2.type === <span class="string">&quot;svg&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新元素</span></span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> patchElement = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = (n2.el = n1.el);</span><br><span class="line">  <span class="keyword">const</span> oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ;</span><br><span class="line">  <span class="keyword">const</span> newProps = n2.props || EMPTY_OBJ;</span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  patchProps(</span><br><span class="line">    el,</span><br><span class="line">    n2,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> areChildrenSVG = isSVG &amp;&amp; n2.type !== <span class="string">&quot;foreignObject&quot;</span>;</span><br><span class="line">  <span class="comment">// 更新子节点</span></span><br><span class="line">  patchChildren(</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    el,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    areChildrenSVG</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，更新元素的过程主要做两件事情：更新 <code>props</code> 和更新子节点。其实这是很好理解的，因为一个 <code>DOM</code> 节点元素就是由它自身的一些属性和子节点构成的。</p><p>首先是更新 <code>props</code>，这里的 <code>patchProps</code> 函数就是在更新 <code>DOM</code> 节点的 <code>class、style、event</code> 以及其它的一些 <code>DOM</code> 属性</p><p>其次是更新子节点，我们来看一下这里的 <code>patchChildren</code> 函数的实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  n1,</span></span></span><br><span class="line"><span class="params"><span class="function">  n2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  anchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.children;</span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> c2 = n2.children;</span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = n2;</span><br><span class="line">  <span class="comment">// 子节点有 3 种可能情况：文本、数组、空</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 数组 -&gt; 文本，则删除之前的子节点</span></span><br><span class="line">      unmountChildren(c1, parentComponent, parentSuspense);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">      <span class="comment">// 文本对比不同，则替换为新文本</span></span><br><span class="line">      hostSetElementText(container, c2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是数组</span></span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 新的子节点仍然是数组，则做完整地 diff</span></span><br><span class="line">        patchKeyedChildren(</span><br><span class="line">          c1,</span><br><span class="line">          c2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组 -&gt; 空，则仅仅删除之前的子节点</span></span><br><span class="line">        unmountChildren(c1, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是文本节点或者为空</span></span><br><span class="line">      <span class="comment">// 新的子节点是数组或者为空</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前子节点是文本，则把它清空</span></span><br><span class="line">        hostSetElementText(container, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新的子节点是数组，则挂载新子节点</span></span><br><span class="line">        mountChildren(</span><br><span class="line">          c2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>对于一个元素的子节点 vnode 可能有三种情况：纯文本、vnode 数据 和 空。所以排列组合更新的时候就有 9 种情况</strong></p><ol><li><p>首先来看一下旧子节点是纯文本的情况：</p><ul><li><p>如果新子节点也是纯文本，那么做简单地文本替换即可；</p></li><li><p>如果新子节点是空，那么删除旧子节点即可；</p></li><li><p>如果新子节点是 vnode 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。</p></li></ul></li><li><p>接下来看一下旧子节点是空的情况：</p><ul><li><p>如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可；</p></li><li><p>如果新子节点也是空，那么什么都不需要做；</p></li><li><p>如果新子节点是 vnode 数组，那么直接去旧子节点的父容器下添加多个新子节点即可。</p></li></ul></li><li><p>最后来看一下旧子节点是 vnode 数组的情况：</p><ul><li><p>如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点；</p></li><li><p>如果新子节点是空，那么删除旧子节点即可；</p></li><li><p>如果新子节点也是 vnode 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了核心 diff 算法。</p></li></ul></li></ol><h2 id="组件更新：完整的-DOM-diff-流程是怎样的？（下）"><a href="#组件更新：完整的-DOM-diff-流程是怎样的？（下）" class="headerlink" title="组件更新：完整的 DOM diff 流程是怎样的？（下）"></a>组件更新：完整的 DOM diff 流程是怎样的？（下）</h2><p>在 <code>processElement</code> 中，处理子节点的时候，当前后都是节点数组的时候，就执行核心的 <code>diff</code> 算法</p><p>新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心 diff 算法，就是在已知旧子节点 DOM 结构，vnode 和新子节点 vnode 情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作</p><h3 id="同步头部节点"><a href="#同步头部节点" class="headerlink" title="同步头部节点"></a>同步头部节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i];</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[i];</span><br><span class="line">    <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      <span class="comment">// 相同的节点，递归执行 patch 更新节点</span></span><br><span class="line">      patch(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        parentAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在整个 diff 的过程，我们需要维护几个变量：头部索引 <code>i</code>，旧子节点的尾部索引 <code>e1</code> 和新子节点的尾部索引 <code>e2</code></p><p>同步头部节点就是从头部开始，依次对比新节点和旧节点，如果他们相同则执行 patch 更新节点，如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束</p><h3 id="同步尾部节点"><a href="#同步尾部节点" class="headerlink" title="同步尾部节点"></a>同步尾部节点</h3><p>接着从尾部开始同步尾部节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1];</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[e2];</span><br><span class="line">    <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      patch(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        parentAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e1--;</span><br><span class="line">    e2--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点，如果不同或者索引 i 大于 e1 或者 e2 则同步过程结束</p><p>接下来有三种情况需要处理：</p><ul><li>新子节点剩余要添加的新节点</li><li>旧子节点剩余要删除的多余节点</li><li>未知子序列</li></ul><h3 id="添加新节点"><a href="#添加新节点" class="headerlink" title="添加新节点"></a>添加新节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="comment">// 3. 挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="comment">// 挂载新节点</span></span><br><span class="line">        patch(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          c2[i],</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        );</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果索引 i 大于尾部索引 e1 且小于 e2，那么从索引 i 开始到索引 e2 之间，我们直接挂载子树这部分的节点</p><h3 id="删除多余节点"><a href="#删除多余节点" class="headerlink" title="删除多余节点"></a>删除多余节点</h3><p>如果不满足添加新节点的情况，我们就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c d e</span></span><br><span class="line">  <span class="comment">// (a b) d e</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="comment">// 不满足</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      unmount(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果索引 i 大于尾部索引 e2，那么从索引 i 开始到索引 e1 之间，我们直接删除旧子树这部分的节点</p><h3 id="处理未知子序列"><a href="#处理未知子序列" class="headerlink" title="处理未知子序列"></a>处理未知子序列</h3><p>单纯的添加和删除节点都是比较理想的情况，操作起来也很容易，但是有些时候并非这么幸运，我们会遇到比较复杂的未知子序列</p><p>当我们完成前后的移动后，得到中间的两个子序列，记录开始位置 s1 s2</p><h4 id="根据-key-建立新子序列的索引图"><a href="#根据-key-建立新子序列的索引图" class="headerlink" title="根据 key 建立新子序列的索引图"></a>根据 key 建立新子序列的索引图</h4><p>通常我们在开发过程中， 会给 v-for 生成的列表中的每一项分配唯一 key 作为项的唯一的 ID，这个 key 在 diff 过程中起到很关键的作用。对于新旧子序列中的节点，我们认为 key 相同就是同一个节点，直接执行 patch 即可</p><p>根据 key 建立新子序列的索引图</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i; <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图 Map&lt;key, index&gt;</span></span><br><span class="line">  <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[i];</span><br><span class="line">    keyToNewIndexMap.set(nextChild.key, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更新和移除旧节点"><a href="#更新和移除旧节点" class="headerlink" title="更新和移除旧节点"></a>更新和移除旧节点</h4><p>接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出需要移动的节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点，不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i;</span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 新子序列已更新节点的数量</span></span><br><span class="line">  <span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 新子序列待更新节点的数量，等于新子序列的长度</span></span><br><span class="line">  <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 是否存在要移动的节点</span></span><br><span class="line">  <span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 用于跟踪判断是否有节点移动</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="built_in">Array</span>(toBePatched);</span><br><span class="line">  <span class="comment">// 初始化数组，每个元素的值都是 0</span></span><br><span class="line">  <span class="comment">// 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 正序遍历旧子序列</span></span><br><span class="line">  <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">    <span class="comment">// 拿到每一个旧子序列节点</span></span><br><span class="line">    <span class="keyword">const</span> prevChild = c1[i];</span><br><span class="line">    <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">      <span class="comment">// 所有新的子序列节点都已经更新，剩余的节点删除</span></span><br><span class="line">      unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找旧子序列中的节点在新子序列中的索引</span></span><br><span class="line">    <span class="keyword">let</span> newIndex = keyToNewIndexMap.get(prevChild.key);</span><br><span class="line">    <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 找不到说明旧子序列已经不存在于新子序列中，则删除该节点</span></span><br><span class="line">      unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解</span></span><br><span class="line">      newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动</span></span><br><span class="line">      <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">        maxNewIndexSoFar = newIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moved = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新新旧子序列中匹配的节点</span></span><br><span class="line">      patch(</span><br><span class="line">        prevChild,</span><br><span class="line">        c2[newIndex],</span><br><span class="line">        container,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      );</span><br><span class="line">      patched++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="移动和挂载新节点"><a href="#移动和挂载新节点" class="headerlink" title="移动和挂载新节点"></a>移动和挂载新节点</h4><p>最后我们就要移动和挂载新节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  c1,</span></span></span><br><span class="line"><span class="params"><span class="function">  c2,</span></span></span><br><span class="line"><span class="params"><span class="function">  container,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentAnchor,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentSuspense,</span></span></span><br><span class="line"><span class="params"><span class="function">  isSVG,</span></span></span><br><span class="line"><span class="params"><span class="function">  optimized</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = c2.length;</span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g</span></span><br><span class="line">  <span class="comment">// (a b) e c d h f g</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i;</span><br><span class="line">  <span class="comment">// 新子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i; <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 5.3 移动和挂载新节点</span></span><br><span class="line">  <span class="comment">// 仅当节点移动时生成最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">    ? getSequence(newIndexToOldIndexMap)</span><br><span class="line">    : EMPTY_ARR;</span><br><span class="line">  <span class="keyword">let</span> j = increasingNewIndexSequence.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 倒序遍历以便我们可以使用最后更新的节点作为锚点</span></span><br><span class="line">  <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextIndex = s2 + i;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[nextIndex];</span><br><span class="line">    <span class="comment">// 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].el : parentAnchor;</span><br><span class="line">    <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 挂载新的子节点</span></span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        nextChild,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="comment">// 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">        move(nextChild, container, anchor, <span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序递增子序列</span></span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue.js 的更新粒度是组件级别的，并且 Vue.js 在 patch 某个组件的时候，如果遇到组件这类抽象节点，在某些条件下也会触发子组件的更新。</p><p>对于普通元素节点的更新，主要是更新一些属性，以及它的子节点。子节点的更新又分为多种情况，其中最复杂的情况为数组到数组的更新，内部又根据不同情况分成几个流程去 diff，遇到需要移动的情况还要去求解子节点的最长递增子序列。</p><p>整个更新过程还是利用了树的深度遍历，递归执行 patch 方法，最终完成了整个组件树的更新。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Vue-js-的优化&quot;&gt;&lt;a href=&quot;#Vue-js-的优化&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 的优化&quot;&gt;&lt;/a&gt;Vue.js 的优化&lt;/h1&gt;&lt;p&gt;Vue 3.0 从源码、性能和语法 API 三个大的方面优化了框架，也提高了开发人员的开发体验，相比于 2.x 有了很大的一个改变&lt;/p&gt;</summary>
    
    
    
    <category term="vue" scheme="https://iiicon.github.io/blog-next/categories/vue/"/>
    
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="vue3" scheme="https://iiicon.github.io/blog-next/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化实践笔记</title>
    <link href="https://iiicon.github.io/blog-next/2020/08/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
    <id>https://iiicon.github.io/blog-next/2020/08/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-18T03:17:36.000Z</published>
    <updated>2021-12-21T06:04:02.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是浏览器的热更新"><a href="#什么是浏览器的热更新" class="headerlink" title="什么是浏览器的热更新"></a>什么是浏览器的热更新</h2><h3 id="Auto-Compile-保存后自动编译"><a href="#Auto-Compile-保存后自动编译" class="headerlink" title="Auto Compile 保存后自动编译"></a>Auto Compile 保存后自动编译</h3><p>配置 watch:true 实现代码 auto compile</p><h3 id="live-reload-自动刷新浏览器"><a href="#live-reload-自动刷新浏览器" class="headerlink" title="live reload 自动刷新浏览器"></a>live reload 自动刷新浏览器</h3><p>为了每次代码修改页面都能自动刷新而无需手动点击，我们需要一种通讯机制来连接浏览器中的预览页面与本地监控代码变更的进程</p><p>官方的 devServer 通过 websocket 链接，就可以使打开的网页和本地服务间建立持久化的通信。当源代码发生变更时，我们就可以通过 Socket 通知到网页端，网页端在接到通知后会自动触发页面刷新。</p><h3 id="Hot-Module-Replacement-模块热替换"><a href="#Hot-Module-Replacement-模块热替换" class="headerlink" title="Hot Module Replacement 模块热替换"></a>Hot Module Replacement 模块热替换</h3><p>为了解决页面刷新导致的状态丢失问题，webpack 提出了模块热替换的概念，完整的 HMR 功能主要包含了三方面的技术：</p><p>watch 示例中体现的，对本地源代码文件内容变更的监控。</p><p>instant reload 示例中体现的，浏览器网页端与本地服务器端的 Websocket 通信。</p><p>hmr 示例中体现的，也即是最核心的，模块解析与替换功能。</p><p><img src="https://i.loli.net/2020/08/19/WVbzCnZMirKQL3B.png" alt="hmr.png" loading="lazy"></p><p>也就是说在这三种技术中，我们可以基于 Node.js 中提供的文件模块 fs.watch 来实现对文件和文件夹的监控，同样也可以使用 sockjs-node 或 socket.io 来实现 Websocket 的通信。</p><h3 id="webpack-中的打包流程"><a href="#webpack-中的打包流程" class="headerlink" title="webpack 中的打包流程"></a>webpack 中的打包流程</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>module：指在模块化编程中我们把应用程序分割成的独立功能的代码模块。</p></li><li><p>chunk：指模块间按照引用关系组合成的代码块，一个 chunk 中可以包含多个 module 。</p></li><li><p>chunk group：指通过配置入口点（entry point）区分的块组，一个 chunk group 中可包含一到多个 chunk 。</p></li><li><p>bundling：webpack 打包的过程。</p></li><li><p>asset/bundle：打包产物。</p></li></ul><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ol><li>一切源代码文件均可通过各种 Loader 转换为 JS 模块 （module），模块之间可以互相引用。</li><li>webpack 通过入口点（entry point）递归处理各模块引用关系，最后输出为一个或多个产物包 js(bundle) 文件。</li><li>每一个入口点都是一个块组（chunk group），在不考虑分包的情况下，一个 chunk group 中只有一个 chunk，该 chunk 包含递归分析后的所有模块。每一个 chunk 都有对应的一个打包后的输出文件（asset/bundle）。</li></ol><p>在上面的 hmr 示例中，从 entry 中的 &#39;./src/index1.js&#39; 到打包产物的 dist/main.js ，以模块的角度而言，其基本流程是：</p><ol><li>唯一 entry 创建一个块组（chunk group）， name 为 main ，包含了 ./src/index1.js 这一个模块。</li><li>在解析器中处理 ./src/index1.js 模块的代码，找到了其依赖的 &#39;./style.css&#39; ，找到匹配的 loader: css-loader 和 style-loader 。</li><li>首先通过 css-loader 处理，将 css-loader/dist/cjs.js!./src/style.css 模块（即把 CSS 文件内容转化为 js 可执行代码的模块，这里简称为 Content 模块）和 css-loader/dist/runtime/api.js 模块打入 chunk 中。// ?</li><li>然后通过 style-loader 处理，将 style-loader/dist/runtime/injectStylesIntoStyleTag.js 模块 （我们这里简称为 API 模块），以及处理后的 .src/style.css 模块（作用是运行时中通过 API 模块将 Content 模块内容注入 Style 标签）导入 chunk 中。</li><li>依次类推，直到将所有依赖的模块均打入到 chunk 中，最后输出名为 main.js 的产物（我们称为 Asset 或 Bundle）。</li></ol><p>style-loader 中的热替换代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cssContentPath = <span class="string">&quot;./node_modules/css-loader/dist/cjs.js!./src/style.css&quot;</span></span><br><span class="line"><span class="keyword">var</span> api = __webpack_require__(<span class="string">&quot;./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> content = __webpack_require__(cssContentPath);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> update = api(content, options);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.hot.accept(</span><br><span class="line">  cssContentPath,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    content = __webpack_require__(cssContentPath);</span><br><span class="line">    ...</span><br><span class="line">    update(content);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">module</span>.hot.dispose(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  update();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="HotModuleReplacementPlugin-模块热替换插件"><a href="#HotModuleReplacementPlugin-模块热替换插件" class="headerlink" title="HotModuleReplacementPlugin 模块热替换插件"></a>HotModuleReplacementPlugin 模块热替换插件</h3><p>对指定的 js 文件实现热替换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//./text.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> text = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">//./index2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; text &#125; <span class="keyword">from</span> <span class="string">&quot;./text.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  div.innerHTML = text;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./text.js&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    render();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中我们可以看到，热替换的实现，既依赖 webpack 核心代码中 HotModuleReplacementPlugin 所提供的相关 API，也依赖在具体模块的加载器中实现相应 API 的更新替换逻辑</p><h2 id="正确使用-Source-Map"><a href="#正确使用-Source-Map" class="headerlink" title="正确使用 Source Map"></a>正确使用 Source Map</h2><p>一种在调试时将产物代码显示回源代码的功能</p><h3 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h3><ul><li><p><code>false</code>：即不开启 <code>source map</code> 功能，其他不符合上述规则的赋值也等价于 <code>false</code> 。</p></li><li><p><code>eval</code>：是指在编译器中使用 <code>EvalDevToolModulePlugin</code> 作为 <code>sourcemap 的处理插件</code>。</p></li><li><p><code>[xxx-...]source-map</code>：根据 <code>devtool</code> 对应值中是否有 <code>eval</code> 关键字来决定使用 <code>EvalSourceMapDevToolPlugin</code> 或 <code>SourceMapDevToolPlugin</code> 作为 <code>sourcemap</code> 的处理插件，其余关键字则决定传入到插件的相关字段赋值。</p></li><li><p><code>inline</code>：决定是否传入插件的 <code>filename</code> 参数，作用是决定单独生成 <code>source map</code> 文件还是在行内显示，该参数在<code> eval-</code> 参数存在时无效。</p></li><li><p><code>hidden</code>：决定传入插件 <code>append</code> 的赋值，作用是判断是否添加 <code>SourceMappingURL</code> 的注释，该参数在 <code>eval-</code> 参数存在时无效。</p></li><li><p><code>module</code>：为 <code>true</code> 时传入插件的 <code>module</code> 为 <code>true</code> ，作用是为加载器（Loaders）生成 <code>source map</code> 。</p></li><li><p><code>cheap</code>：这个关键字有两处作用。首先，当 <code>module</code> 为 <code>false</code> 时，它决定插件 <code>module</code> 参数的最终取值，最终取值与 <code>cheap</code> 相反。其次，它决定插件 <code>columns</code> 参数的取值，作用是决定生成的 <code>source map</code> 中是否包含列信息，在不包含列信息的情况下，调试时只能定位到指定代码所在的行而定位不到所在的列。</p></li><li><p><code>nosource</code>：<code>nosource</code> 决定了插件中 <code>noSource</code> 变量的取值，作用是决定生成的 <code>source map</code> 中是否包含源代码信息，不包含源码情况下只能显示调用堆栈信息。</p></li></ul><h3 id="Source-Map-处理插件"><a href="#Source-Map-处理插件" class="headerlink" title="Source Map 处理插件"></a>Source Map 处理插件</h3><p>从上面的规则中我们还可以看到，根据不同规则，实际上 webpack 是从三种插件中选择其一作为 source map 的处理插件</p><ul><li><p><code>EvalDevToolModulePlugin</code>：模块代码后添加 <code>sourceURL=webpack:///+ 模块引用路径</code>，不生成 <code>source map</code> 内容，模块产物代码通过 <code>eval()</code> 封装。</p></li><li><p><code>EvalSourceMapDevToolPlugin</code>：生成 <code>base64</code> 格式的 <code>source map</code> 并附加在模块代码之后， <code>source map</code> 后添加 <code>sourceURL=webpack:///+ 模块引用路径</code>，不单独生成文件，模块产物代码通过 <code>eval()</code> 封装。</p></li><li><p><code>SourceMapDevToolPlugin</code>：生成单独的 <code>.map</code> 文件，模块产物代码不通过 <code>eval</code> 封装。</p></li></ul><h3 id="开发环境下-Source-Map-推荐预设"><a href="#开发环境下-Source-Map-推荐预设" class="headerlink" title="开发环境下 Source Map 推荐预设"></a>开发环境下 Source Map 推荐预设</h3><ul><li><p>通常来说，开发环境首选哪一种预设取决于 <code>source map</code> 对于我们的帮助程度。</p></li><li><p>如果对项目代码了如指掌，查看产物代码也可以无障碍地了解对应源代码的部分，那就可以关闭 <code>devtool</code> 或使用 <code>eval</code> 来获得最快构建速度。</p></li><li><p>反之如果在调试时，需要通过 <code>source map</code> 来快速定位到源代码，则优先考虑使用 <code>eval-cheap-module-source-map</code>，它的质量与初次/再次构建速度都属于次优级，以牺牲定位到列的功能为代价换取更快的构建速度通常也是值得的。</p></li><li><p>在其他情况下，根据对质量要求更高或是对速度要求更高的不同情况，可以分别考虑使用 <code>eval-source-map</code> 或 <code>eval-cheap-source-map</code>。</p></li></ul><p>了解了开发环境下如何选择 source map 预设后，我们再来补充几种工具和脚手架中的默认预设：</p><ul><li><p><code>webpack</code> 配置中，如果不设定 <code>devtool</code> ，则使用默认值 <code>eval</code> ，即速度与 <code>devtool:false</code> 几乎相同、但模块代码后多了 <code>sourceURL</code> 以帮助定位模块的文件名称。</p></li><li><p><code>create-react-app</code> 中，在生产环境下，根据 <code>shouldUseSourceMap</code> 参数决定使用 <code>‘source-map’</code> 或 <code>false</code> ；在开发环境下使用 <code>cheap-module-source-map</code>（不包含列信息的源代码，但更快）。</p></li><li><p><code>vue-cli-service</code> 中，与 <code>creat-react-app</code> 中相同。</p></li></ul><h3 id="不同预设的效果总结"><a href="#不同预设的效果总结" class="headerlink" title="不同预设的效果总结"></a>不同预设的效果总结</h3><ul><li><p>质量：生成的 source map 的质量分为 5 个级别，对应的调试便捷性依次降低：源代码 &gt; 缺少列信息的源代码 &gt; loader 转换后的代码 &gt; 生成后的产物代码 &gt; 无法显示代码（具体参见下面的不同质量的源码示例小节）。对应对质量产生影响的预设关键字优先级为 <code>souce-map = eval-source-map &gt; cheap-module- &gt; cheap- &gt; eval = none &gt; nosource-</code></p></li><li><p>构建的速度：<br>开发环境下 eval- 对应的 <code>EvalSourceMapDevToolPlugin</code> 整体要快于不带 <code>eval-</code> 的 <code>SourceMapDevToolPlugin</code> 。尤其在质量最佳的配置下，<code>eval-source-map</code> 的再次构建速度要远快于其他几种<br>在生产环境下：通常不会开启再次构建，因此相比再次构建，初次构建的速度更值得关注，甚至对构建速度以外因素的考虑要优先于对构建速度的考虑</p></li><li><p>包的大小和生成方式：在开发环境下我们并不需要关注这些因素，正如在开发环境下也通常不考虑使用分包等优化方式。我们需要关注速度和质量来保证我们的高效开发体验，而其他的部分则是在生产环境下需要考虑的问题。</p></li></ul><h3 id="EvalSourceMapDevToolPlugin-的使用"><a href="#EvalSourceMapDevToolPlugin-的使用" class="headerlink" title="EvalSourceMapDevToolPlugin 的使用"></a>EvalSourceMapDevToolPlugin 的使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack.config.js </span><br><span class="line">  ... </span><br><span class="line">  <span class="comment">//devtool: &#x27;eval-source-map&#x27;, </span></span><br><span class="line">  <span class="attr">devtool</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">plugins</span>: [ </span><br><span class="line">    <span class="keyword">new</span> webpack.EvalSourceMapDevToolPlugin(&#123; </span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, </span><br><span class="line">      <span class="built_in">module</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="attr">columns</span>: <span class="literal">false</span> </span><br><span class="line">    &#125;) </span><br><span class="line">  ], </span><br><span class="line">  ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们将 <code>devtool</code> 设为 <code>false</code> ，而直接使用 <code>EvalSourceMapDevToolPlugin</code> ，通过传入 <code>module: true</code> 和 <code>column:false</code>，达到和预设 <code>eval-cheap-module-source-map</code> 一样的质量，同时传入 <code>exclude</code> 参数，排除第三方依赖包的 <code>source map</code> 生成。保存设定后通过运行可以看到，在文件体积减小（尽管开发环境并不关注文件大小）的同时，再次构建的速度相比上面表格中的速度提升了将近一倍，达到了最快一级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是浏览器的热更新&quot;&gt;&lt;a href=&quot;#什么是浏览器的热更新&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器的热更新&quot;&gt;&lt;/a&gt;什么是浏览器的热更新&lt;/h2&gt;&lt;h3 id=&quot;Auto-Compile-保存后自动编译&quot;&gt;&lt;a href=&quot;#A</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://iiicon.github.io/blog-next/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="笔记" scheme="https://iiicon.github.io/blog-next/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="scaffold" scheme="https://iiicon.github.io/blog-next/tags/scaffold/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="https://iiicon.github.io/blog-next/2020/08/06/%E9%9D%A2%E8%AF%95/"/>
    <id>https://iiicon.github.io/blog-next/2020/08/06/%E9%9D%A2%E8%AF%95/</id>
    <published>2020-08-06T06:00:52.000Z</published>
    <updated>2021-12-21T06:04:02.383Z</updated>
    
    <content type="html"><![CDATA[<p>- </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;- &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6之Symbol</title>
    <link href="https://iiicon.github.io/blog-next/2020/08/06/ES6%E4%B9%8BSymbol/"/>
    <id>https://iiicon.github.io/blog-next/2020/08/06/ES6%E4%B9%8BSymbol/</id>
    <published>2020-08-06T03:48:43.000Z</published>
    <updated>2021-12-21T06:04:02.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><pre><code>let race = &#123;  b: Symbol(),  y: Symbol(),  w: Symbol()&#125;</code></pre><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 &#39;symbol&#39;</li><li>Symbol 函数钱不能使用 new 命令，否则会报错，这是因为生成的 Symbol 是一个原始类型的值，不是对象</li><li>instanceof 的值为 false</li><li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</li><li>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值</li><li>Symbol 函数的参数只是表示对当前Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的</li><li>Symbol 值不能与其他类型的值进行运算，会报错</li><li>Symbol 值可以显示转为字符串</li><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性</li><li>Symbol 作为属性名，该属性不会出现在 <code>for in</code>  <code>for of</code>循环中，也不会被 <code>Object.keys()</code> <code>Object.getOwnPropertyNames()</code> <code>JSON.stringify()</code> 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名</li><li>如果我们希望使用同一个 Symbol 值，可以用 <code>Symbol.for</code>，它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key</li></ol><p>? Symbol 是不是一个引用，Symbol.iterator 代表什么，因为能访问， 所以 Symbol 可以理解成是一个引用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Symbol&quot;&gt;&lt;a href=&quot;#Symbol&quot; class=&quot;headerlink&quot; title=&quot;Symbol&quot;&gt;&lt;/a&gt;Symbol&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;let race = &amp;#123;
  b: Symbol(),
  y: Symbol()</summary>
      
    
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/categories/js/"/>
    
    
    <category term="G" scheme="https://iiicon.github.io/blog-next/tags/G/"/>
    
    <category term="es6" scheme="https://iiicon.github.io/blog-next/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>面试题库</title>
    <link href="https://iiicon.github.io/blog-next/2020/07/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    <id>https://iiicon.github.io/blog-next/2020/07/23/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</id>
    <published>2020-07-23T08:03:19.000Z</published>
    <updated>2021-12-21T06:04:02.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1-如何理解-html-语义化？"><a href="#1-如何理解-html-语义化？" class="headerlink" title="1.如何理解 html 语义化？"></a>1.如何理解 html 语义化？</h3><ul><li>举例法：HTML 语义化就是使用正确的标签 段落就写 p 标签，标题就写 h1 标签，文章就写 article 标签，视频就写 video 标签，等等</li><li>阐述法：首先讲以前的后台开发人员使用 table 布局，然后讲美工人员使用 div+css 布局，最后讲专业的前端会使用正确的标签进行页面开发</li></ul><h3 id="2-meta-viewport-是做什么的？怎么写"><a href="#2-meta-viewport-是做什么的？怎么写" class="headerlink" title="2.meta viewport 是做什么的？怎么写"></a>2.meta viewport 是做什么的？怎么写</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;</code></p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="1-列举常见的-es6-属性"><a href="#1-列举常见的-es6-属性" class="headerlink" title="1.列举常见的 es6 属性"></a>1.列举常见的 es6 属性</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zZ3cud2lraS9lcy02LXR1dG9yaWFscy8=">es-6<i class="fa fa-external-link-alt"></i></span></p><h3 id="2-函数防抖和函数节流分别是什么？"><a href="#2-函数防抖和函数节流分别是什么？" class="headerlink" title="2.函数防抖和函数节流分别是什么？"></a>2.函数防抖和函数节流分别是什么？</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi91dGlscy9ibG9iL21hc3Rlci9zcmMvdW5kZXJzY29yZS9kZWJvdW5jZS5qcw==">防抖<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi91dGlscy9ibG9iL21hc3Rlci9zcmMvdW5kZXJzY29yZS90aHJvdHRsZS5qcw==">节流<i class="fa fa-external-link-alt"></i></span></p><h3 id="3-如何实现数组去重？"><a href="#3-如何实现数组去重？" class="headerlink" title="3.如何实现数组去重？"></a>3.如何实现数组去重？</h3><ul><li>遍历比较</li><li>计数排序变形</li><li>使用 Set</li><li>使用 WeakMap</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-GET-和-POST-的区别"><a href="#1-GET-和-POST-的区别" class="headerlink" title="1.GET 和 POST 的区别"></a>1.GET 和 POST 的区别</h3><p>错解，但面试满分：</p><ul><li><code>GET</code> 在浏览器回退时是无害的，而 <code>POST</code> 会再次提交请求。</li><li><code>GET</code> 产生的 URL 地址可以被加入收藏栏，而 <code>POST</code> 不可以。</li><li><code>GET</code> 请求会被浏览器主动 cache，而 <code>POST</code> 不会，除非手动设置。</li><li><code>GET</code> 请求只能进行 url 编码，而 <code>POST</code> 支持多种编码方式。</li><li><code>GET</code> 请求参数会被完整保留在浏览器历史记录里，而 <code>POST</code> 中的参数不会被保留。</li><li><code>GET</code> 请求在 URL 中传送的参数是有长度限制的，而 <code>POST</code> 么有。</li><li>对参数的数据类型，<code>GET</code> 只接受 <code>ASCII</code> 字符，而 <code>POST</code> 没有限制。</li><li><code>GET</code> 比 <code>POST</code> 更不安全，因为参数直接暴露在 <code>URL</code> 上，所以不能用来传递敏感信息。</li><li><code>GET</code> 参数通过 <code>URL</code> 传递，<code>POST</code> 放在 <code>Request body</code> 中。</li></ul><p>正解：</p><ul><li>就一个区别：语义——<code>GET</code> 用于获取资源，<code>POST</code> 用于提交资源。</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="1-watch-和-computed-和-methods-的区别是什么？"><a href="#1-watch-和-computed-和-methods-的区别是什么？" class="headerlink" title="1. watch 和 computed 和 methods 的区别是什么？"></a>1. watch 和 computed 和 methods 的区别是什么？</h3><ul><li><code>computed</code> 和 <code>methods</code> 相比，最大区别是 <code>computed</code> 有缓存：如果 <code>computed</code> 属性依赖的属性没有变化，那么 <code>computed</code> 属性就不会重新计算， <code>methods</code> 则是看到一次计算一次</li><li><code>watch</code> 和 <code>computed</code> <code>相比，computed</code> 是计算出一个属性（废话），而 <code>watch</code> 则可能是做别的事情（如上报数据）</li></ul><h3 id="vuejs-1-x-和-2-x-使用-Object-defineProperty-来劫持数据的-getter-和-setter，它有什么缺点？（或者-vue3-为什么要用-proxy）"><a href="#vuejs-1-x-和-2-x-使用-Object-defineProperty-来劫持数据的-getter-和-setter，它有什么缺点？（或者-vue3-为什么要用-proxy）" class="headerlink" title="vuejs 1.x 和 2.x 使用 Object.defineProperty 来劫持数据的 getter 和 setter，它有什么缺点？（或者 vue3 为什么要用 proxy）"></a>vuejs 1.x 和 2.x 使用 Object.defineProperty 来劫持数据的 getter 和 setter，它有什么缺点？（或者 vue3 为什么要用 proxy）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>Object.defineProperty</code> 需要预先知道要拦截的 <code>key</code> 是什么，所以它并不能检测对象属性的添加和删除。</li><li>对于层级比较深的对象，<code>vue</code> 会使用 <code>Object.defineProperty</code> 把每一层对象数据都变成响应式的。如果我们的响应式对象很复杂，就会有相当大的性能负担</li><li><code>Proxy</code> 劫持的是整个对象, 自然对于对象属性的增加和删除都能检测到</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1-受控组件-V-S-非受控组件"><a href="#1-受控组件-V-S-非受控组件" class="headerlink" title="1. 受控组件 V.S. 非受控组件"></a>1. 受控组件 V.S. 非受控组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;FInput value=&#123;x&#125; onChange=&#123;fn&#125;/&gt; 受控组件</span><br><span class="line">&lt;FInput defaultValue=&#123;x&#125; ref=&#123;input&#125;/&gt; 非受控组件</span><br></pre></td></tr></table></figure><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><ol><li>各个模块加载方案已经区别</li></ol><ul><li><p>AMD<br>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi9qcy1tb2R1bGVzL3RyZWUvbWFzdGVyL3NyYy9yZXF1aXJlanM=">AMD demo<i class="fa fa-external-link-alt"></i></span></p></li><li><p>CMD<br>CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出。主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi9qcy1tb2R1bGVzL3RyZWUvbWFzdGVyL3NyYy9zZWFqcw==">CMD demo<i class="fa fa-external-link-alt"></i></span></p><p><em>1.CMD 推崇依赖就近，AMD 推崇依赖前置 2.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行</em></p></li><li><p>CommonJS<br>在服务器端比如 node，采用的则是 CommonJS 规范<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi9qcy1tb2R1bGVzL3RyZWUvbWFzdGVyL3NyYy9jb21tb25KUw==">CommonJS demo<i class="fa fa-external-link-alt"></i></span></p><p><em>CommonJS 和 AMD 对比就是 commonjs 是同步的，AMD 规范则是非同步加载模块，允许指定回调函数。</em></p></li><li><p>ES6 模块<br>ECMAScript2015 规定了新的模块加载方案，需要使用的模块先加载完再执行代码<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpaWNvbi9qcy1tb2R1bGVzL3RyZWUvbWFzdGVyL3NyYy9FUzY=">ES6 demo<i class="fa fa-external-link-alt"></i></span></p><p><em>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</em><br><em>因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</em></p></li></ul><h2 id="开放题目"><a href="#开放题目" class="headerlink" title="开放题目"></a>开放题目</h2><h3 id="1-你遇到最难的问题是怎样的？"><a href="#1-你遇到最难的问题是怎样的？" class="headerlink" title="1. 你遇到最难的问题是怎样的？"></a>1. 你遇到最难的问题是怎样的？</h3><p>评分可参考如下场景</p><blockquote><p>一开始没搞懂<br>去网上看了个答案<br>一试发现这个广为流传的答案是有坑的<br>于是自己看 issue<br>发现还有一个小细节<br>然后解决了<br>谁知道还是在某种 edge case 有问题<br>于是自己看规范看源码，搞定</p></blockquote><h3 id="2-最近在关注什么新技术？"><a href="#2-最近在关注什么新技术？" class="headerlink" title="2. 最近在关注什么新技术？"></a>2. 最近在关注什么新技术？</h3><h2 id="刁钻题目"><a href="#刁钻题目" class="headerlink" title="刁钻题目"></a>刁钻题目</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>Q: <code>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3)</code> 可能为 <code>true</code> 吗？</p><p>A: 第一种</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  valueOf()&#123;</span><br><span class="line">   return this.value++</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> a ==1 &amp;&amp; a== 2 &amp;&amp; a==3 // true</span><br></pre></td></tr></table></figure><p>A: 第二种</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line">Object.defineProperty(window, &#x27;a&#x27;, &#123;</span><br><span class="line">    get()&#123;</span><br><span class="line">        return value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">a ===1 &amp;&amp; a=== 2 &amp;&amp; a===3 // true</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Q: 问 a.x 是多少？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&quot;a&quot;</span> &#125;;</span><br><span class="line">a.x = a = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>A: <code>undefined</code></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Q: <code>[1,2,3].map(parseInt)</code> 输出什么？<br>A: <code>[1, NaN, NaN]</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;h3 id=&quot;1-如何理解-html-语义化？&quot;&gt;&lt;a href=&quot;#1-如何理解-html-语义化？&quot; class=&quot;head</summary>
      
    
    
    
    <category term="总结" scheme="https://iiicon.github.io/blog-next/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="面试题" scheme="https://iiicon.github.io/blog-next/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js设计模式之观察者模式</title>
    <link href="https://iiicon.github.io/blog-next/2020/06/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://iiicon.github.io/blog-next/2020/06/22/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-22T06:50:26.000Z</published>
    <updated>2021-12-21T06:04:02.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>一个典型的观察者模式应用场景是用户在一个网站订阅主题</p><ol><li>多个用户（观察者 observer）都可以订阅某个主题</li><li>当主题内容更新时订阅该主题的用户都能收到通知</li></ol><p>以下是代码实现</p><p>Subject 是构造函数， new Subject 创建一个主题对象，该对象内部维护订阅当前主题的观察者数组，主题对象上有一些方法，<br>如添加观察者（addObserver）,删除观察者（removeObserver）,通知观察者更新（notify），当 notify 时实际上调用全部观察者 observer 自身的 update 方法</p><p>Observer 上构造函数，new Observer 创建一个观察者对象，该对象有一个 update 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addObserver</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addObserver</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">this</span>.observers.indexOf(observer)</span><br><span class="line">    <span class="built_in">this</span>.observers.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">udpate</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">let</span> observer1 = <span class="keyword">new</span> Observer()</span><br><span class="line">observer1.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;observer1 update&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">subject.addObserver(observer1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer2 = <span class="keyword">new</span> Observer(<span class="string">&#x27;valley&#x27;</span>)</span><br><span class="line">observer2.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;observer2 update&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">subject.addObserver(observer2)</span><br><span class="line"></span><br><span class="line">subject.notify()</span><br></pre></td></tr></table></figure><p>上面这段代码中，主题被观察者订阅的写法是 subject.addObserver(observer), 不是很直观，给观察者增加订阅方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">udpate</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">subscribeTo</span>(<span class="params">subject</span>)</span> &#123;</span><br><span class="line">    subject.addObserver(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> Observer();</span><br><span class="line">observer.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;observer update&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">observer.subscribeTo(subject); <span class="comment">//观察者订阅主题</span></span><br><span class="line"></span><br><span class="line">subject.notify();</span><br></pre></td></tr></table></figure><h2 id="简化版（发布订阅）"><a href="#简化版（发布订阅）" class="headerlink" title="简化版（发布订阅）"></a>简化版（发布订阅）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> eventManager = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> eventList = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">on</span>(<span class="params">event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!eventList[event]) &#123;</span><br><span class="line">      eventList[event] = [handler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      eventList[event].push(handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">off</span>(<span class="params">event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(eventList[event]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!handler) &#123;</span><br><span class="line">        <span class="keyword">delete</span> eventList[event]</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = eventList[event].indexOf(handler)</span><br><span class="line">        eventList[event].splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">event, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventList[event]) &#123;</span><br><span class="line">      eventList.forEach(<span class="function"><span class="params">event</span> =&gt;</span> event(data))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    on,</span><br><span class="line">    off,</span><br><span class="line">    trigger,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">eventManager.on(<span class="string">&#x27;say&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line">eventManager.trigger(<span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;一个典型的观察者模式应用场景是用户在一个网站订阅主题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个用户（观察者 observer）</summary>
      
    
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/categories/js/"/>
    
    
    <category term="code" scheme="https://iiicon.github.io/blog-next/tags/code/"/>
    
    <category term="设计模式" scheme="https://iiicon.github.io/blog-next/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>js事件循环</title>
    <link href="https://iiicon.github.io/blog-next/2020/06/16/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>https://iiicon.github.io/blog-next/2020/06/16/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-06-16T08:25:50.000Z</published>
    <updated>2021-12-21T06:04:02.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h2><p>JS 执行是单线程的，它是基于事件循环的，事件循环大致分为以下几个步骤</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>主线程之外，还有一个任务队列（task quene），只要异步任务有了运行结果，就在任务队列中放置一个事件</li><li>一旦执行栈中所有的同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面三步</li></ol><p><img src="https://i.loli.net/2020/06/16/jB4M83ywUmRrtVK.jpg" alt="event-loop.png" loading="lazy"></p><h3 id="常见的-macro-task"><a href="#常见的-macro-task" class="headerlink" title="常见的 macro-task"></a>常见的 macro-task</h3><p>setTimeout MessageChannel postMessage setImmediate</p><h3 id="常见的-micro-task"><a href="#常见的-micro-task" class="headerlink" title="常见的 micro-task"></a>常见的 micro-task</h3><p>MutationObsever Promise.then</p><p>基本的顺序就是</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (macroTask <span class="keyword">of</span> macroTaskQueue) &#123;</span><br><span class="line">    <span class="comment">// 1. Handle current MACRO-TASK</span></span><br><span class="line">    handleMacroTask();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 2. Handle all MICRO-TASK</span></span><br><span class="line">    <span class="keyword">for</span> (microTask <span class="keyword">of</span> microTaskQueue) &#123;</span><br><span class="line">        handleMicroTask(microTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS运行机制&quot;&gt;&lt;a href=&quot;#JS运行机制&quot; class=&quot;headerlink&quot; title=&quot;JS运行机制&quot;&gt;&lt;/a&gt;JS运行机制&lt;/h2&gt;&lt;p&gt;JS 执行是单线程的，它是基于事件循环的，事件循环大致分为以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有同步任</summary>
      
    
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/categories/js/"/>
    
    
    <category term="js" scheme="https://iiicon.github.io/blog-next/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>git撤销回退相关操作</title>
    <link href="https://iiicon.github.io/blog-next/2020/04/15/git%E6%92%A4%E9%94%80%E5%9B%9E%E9%80%80%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>https://iiicon.github.io/blog-next/2020/04/15/git%E6%92%A4%E9%94%80%E5%9B%9E%E9%80%80%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-15T09:15:06.000Z</published>
    <updated>2021-12-21T06:04:02.255Z</updated>
    
    <content type="html"><![CDATA[<p>分支回退的一些操作我们经常会遇到</p><a id="more"></a><h2 id="重置（git-reset）"><a href="#重置（git-reset）" class="headerlink" title="重置（git reset）"></a>重置（git reset）</h2><p>如果因为某些原因（比如新提交导致了 BUG，或只是一个 WIP 提交），需要撤回提交，那么可以使用 git reset 指令。<br>git reset 可以控制当前分支回撤到某次提交时的状态。</p><h3 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a>软重置</h3><p>使用软重置，我们可以撤销提交记录，但是保留新建的文件。（就是我们可以重新提交）<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/meG6Vo0MeviaPS2ZgOV7sV3qpnhsB4LFO8dmv56PCuicTzZTVL6lVp541picccqwMAU36EhACmJCMttPvBJl8tXjQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="soft-reset" loading="lazy"></p><h3 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h3><p>硬重置会把当前工作目录中的文件，以暂存的文件全部移除, <code>git reset --hard HEAD~2</code> 直接回退到两次提交之前的版本，<br>git 也会直接删除记录<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/meG6Vo0MeviaPS2ZgOV7sV3qpnhsB4LFOsiboiaLTHUnlyorlyicvxZtRT9tQD4fcX2VponJIcFUpZHbKKdP5p31vQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="hard-reest" loading="lazy"></p><h2 id="还原（git-revert）"><a href="#还原（git-revert）" class="headerlink" title="还原（git revert）"></a>还原（git revert）</h2><p>还有一种撤销更改的方式，是使用 <code>git revert</code> 命令，用于还原某次提交的修改，会创建一个包含已还原更改的新提交记录（也就是在不修改分支历史的前提下，还原某次提交引入的更改）<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/meG6Vo0MeviaPS2ZgOV7sV3qpnhsB4LFO9KAj8ZGBkjDallvJibGfibgWnfa5ECCY2pOpf6tZwwicv6RGViazjibRiaAg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="revert" loading="lazy"></p><h2 id="检出提交（git-cherry-pick）"><a href="#检出提交（git-cherry-pick）" class="headerlink" title="检出提交（git cherry-pick）"></a>检出提交（git cherry-pick）</h2><p><em>gitLab翻译为优选</em> 把其他分支的提交检出到当前分支，检出之后已经执行了commit</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分支回退的一些操作我们经常会遇到&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://iiicon.github.io/blog-next/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="command" scheme="https://iiicon.github.io/blog-next/tags/command/"/>
    
    <category term="git" scheme="https://iiicon.github.io/blog-next/tags/git/"/>
    
  </entry>
  
</feed>
