---
layout: js
title: 内存泄漏和一次移动端导致的页面崩溃
date: 2019-11-29 17:30:27
tags: [性能优化, 项目总结]
categories: web 性能
---

### 工作中遇到的内存泄漏
最近在做一个数据图表的项目，有用阿里的 AntV 移动端组件 F2，项目是 vue 的 spa 项目，起初的状况就是切换页面大概在30次左右就会导致 F2 不渲染，白屏。刚开始分析是因为脚本加载阻塞导致的，后来打开 chrome 的 performance 测了一下才知道原来是比较严重的内存泄漏，由 F2 创建的图表上的事件和属性在页面切换的时候并不会被 GC，经过查找文档，尝试

```
chart.clear() // 清除画布
chart.destroy() // 销毁 chart 对象以及监听的事件
chart = null // 指向 null，在下个周期 GC
```
终于在 vue 的 beforeDestory 生命周期执行上述操作，终于把内存占用稍稍稳定了
![60快照.png](https://i.loli.net/2019/11/29/fn3eFaY7ubUsWqP.png)

### 什么是内存泄漏？

> 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
> 大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"（garbage collector）。

### 怎么识别内存泄漏

1. 使用 Chrome 任务管理器实时监视内存使用 打开 chrome 浏览器，点击右上角主菜单，选择更多工具->任务管理器，这样就开启了任务管理器面板，然后再右键点击任务管理器的表格标题并启用 JavaScript 使用的内存

内存占用空间(Memory) 列表示原生内存。DOM 节点存储在原生内存中。 如果此值正在增大，则说明正在创建 DOM 节点。
JavaScript 使用的内存(JavaScript Memory) 列表示 JS 堆。此列包含两个值。 您感兴趣的值是实时数字（括号中的数字）。实时数字表示您的页面上的可到达对象正在使用的内存量。 如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。

2. 利用 chrome 时间轴记录可视化内存泄漏
3. 使用堆快照发现已分离 DOM 树的内存泄漏

### 内存泄漏发生的原因

#### 缓存

有时候为了方便数据的快捷复用，我们会使用缓存，但是魂村必须有一个大小上仙才有用，高内存消耗将会导致缓存突破上限，因为缓存内容无法被回收

#### 队列销毁不及时

当浏览器队列销毁不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏

#### 全局变量

除了常规设置了比较大的对象在全局变量中，还可能是意外导致的全局变量

      function foo(arg) {
          bar = "this is a hidden global variable";
      }

#### 计时器中引用没有清除

#### 闭包

#### 事件监听

例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。

### 避免内存泄漏的方法

1.  少用全局变量，避免意外产生的全局变量
2.  使用闭包要及时注意，有 dom 元素的引用要及时清理
3.  计时器里的回调没用的时候要记得销毁
4.  为了避免疏忽导致的遗忘，我们可以用 WeakSet 和 WeakMap 结构，他们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用

        const wm = new WeakMap();

        const element = document.getElementById('example');

        wm.set(element, 'some information');
        wm.get(element) // "some information"

这种情况下，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。
