---
title: 《高程三》读书笔记第六章面向对象
date: 2019-12-16 00:46:52
tags: [js, oop]
categories: 读书笔记
---

## 理解对象

### 对象属性

分为两种 数据属性和访问器属性

数据属性有 [[configurable]] [[Enumerable]] [[Writeable]] [[Value]] 四个特性，value 也是数据的值

访问器属性有 [[Configurable]] [[Enumberable]] [[Get]] [[Set]] 四个特性，一般情况下包括一对 getter 和 setter
访问器属性不能直接定义，必须使用 Object.defineProperty



## 创建对象

### 工厂模式

抽象了创建具体对象的过程的函数

工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题

### 构造函数模式

构造函数的问题就是每个方法都要在构造函数上重新实现一遍

### 原型模式

让所有对象实例共享它所包含的属性和方法
主要问题就是共享的引用类型的数据会有问题

### 组合使用构造函数模式和原型模式（最大限度地节省内存）

这是目前在 js 中使用最广泛、认同度最高的一种创建自定义类型的方法

### 动态原型模式

在构造函数中动态创建原型

### 寄生构造函数模式

就是返回一个函数，这个函数创建一个新的对象，对象做增强
（比如我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数）

### 稳妥构造函数模式

禁止使用的时候可以用



## 继承对象

一般有接口继承和实现继承，js 是实现继承

### 原型链

基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法

### 借用构造函数

主要是为了分开实例属性和原型属性，原型属性要公用，实例属性却不能
可以在子构造函数中调用 超类的构造函数

### 组合继承

组合继承避免了原型链和构造函数的缺陷，融合了他们的优点，称为了 JavaScript 中最常用的继承模式

### 原型式继承

```
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

和 `Object.create()` 的功效是一样的
在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的

### 寄生式继承

该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象（感觉就是在原来的对象的基础上修改 就是返回另一个对象）

### 寄生组合式继承

解决组合继承调用两次的问题，感觉也。。无所谓的呀
