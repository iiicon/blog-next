---
title: 《重构》读书笔记
date: 2020-09-26 23:33:16
tags: [js, 笔记]
categories: 读书笔记
---

## 重构，第一个实例

> 是需求的变化使重构变得必要。如果一段代码能正常工作，并且他不会再被修改，那么完全可以不去重构它。能改进之当然很好，但若没人需要去理解它，它就不会真正妨碍什么。如果确实有人需要理解它的工作原理，并且理解起来很费劲，那你就需要改进一下代码了。
> 要将我的理解转化到代码里，得先将这块代码抽取成一个独立的函数，按它所干的事情给它命名，每次想将一块代码抽取成一个函数时，我都会遵循一个标准流程，最大程度减少犯错的可能，这个流程命名为提炼函数。

- 分解 statement 函数
- 移除 play 临时变量，以查询取代
- 提炼计算观众量积分的逻辑
- 移除 format 变量 (将函数赋值为临时变量，改为一个明确的函数)
- 移除观众量积分总和 (提炼函数和应用内联变量) -> 这两部称为以查询取代临时变量？
- 拆分计算阶段和格式化阶段
- 分离为两个文件（两个阶段）
- 按类型重组计算过程，使用多态计算器来提供数据

## 重构的原则

### 何谓重构

使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。它和性能优化不同，重构是为了让代码更容易理解，更易于修改，这可能使程序运行得更快，也可能使程序运行得更慢

### 两顶帽子

两顶帽子指添加新功能和重构，软件开发过程中经常变换帽子，但是无论何时都清楚自己戴的哪一顶帽子，并且明白不同的帽子对编程状态提出的不同要求

### 为何重构

- 重构改进软件的设计
- 重构使软件更容易理解
- 重构帮助找到 bug
- 重构提高编程速度

### 何时重构

第三次做类似的事情，你就应该重构

- 预备性重构：让添加新功能更容易
- 帮助理解的重构： 使代码更易懂
- 捡垃圾式重构（先记下来）
- 有计划重构和见机行事的重构

#### 长期重构

可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略

#### 复审代码时重构

与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审

#### 怎么对经理说

不要告诉经理！

### 重构的挑战

#### 延缓新功能开发

重构的唯一目的就是让我们开发更快，用更少的
工作量创造更大的价值。

有些人试图用“整洁的代码”“良好的工程实践”之类
道德理由来论证重构的必要性，我认为这是个陷阱。重构的
意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出
发的考量。我们之所以重构，因为它能让我们更快——添加
功能更快，修复 bug 更快。
一定要随时记住这一点，与别人
交流时也要不断强调这一点。重构应该总是由经济利益驱
动。程序员、经理和客户越理解这一点，
“好的设计”那条
曲线就会越经常出现。

#### 代码所有权

#### 分支

#### 测试

#### 遗留代码

### 重构、架构和 YAGNI

### 重构与软件开发过程

### 重构与性能

### 重构起源何处

### 自动化重构

IDE

## 代码的坏味道

> 你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。

### 神秘命名 Mysterious Name

整洁代码最重要的一环就是好的名字

为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

### 重复代码 Duplicated Code

最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数（106）提炼出重复的代码

如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用。

### 过长函数 Long Function

你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。

你可以经常运用以查询取代临时变量（178）来消除临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。

条件表达式和循环常常也是提炼的信号。

### 过长的参数列表 Long Parameter List

如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）
如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法
如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象
如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）
使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组
合成类（144），将这些共同的参数变成这个类的字段

### 全局数据 Global Data

### 可变数据 Mutable Data

对数据的修改经常导致出乎意料的结果和难以发现的 bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了

### 发散式变化 Divergent Change

如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了

### 霰弹式修改 Shotgun Surgery

如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改

### 依赖情节 Feature Envy

一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况

### 数据泥团 Data Clumps

两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象

### 基本类型偏执 Primitive Obsession

很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似 if (a < upper
&& a > lower)这样的代码

### 重复的 switch Repeated Switches

重复的 switch 的问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库

### 循环语句 Loops

用以管道取代循环（231）来让这些老古董退休。我们发现，管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作

### 冗赘的元素 Lazy Element

程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。

### 夸夸其谈通用性 Speculative Generality

当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了

### 临时字段 Temporary Field

有时你会看到这样的类：其内部某个字段仅为某种特定情况而设，这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段

### 过长的消息链 Message Chains

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。

### 中间人  Middle Man

你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道

### 内幕交易 Insider trading 

软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来

### 过大的类 Large Class

如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了

### 异曲同工的类 Alternative Class with Different Interface

使用类的好处之一就在于可以替换：今天用这个类，未来可以换成用另一个类

### 纯数据类 Data Class

所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。这些类早期可能拥有public字段，若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）

纯数据类常常意味着行为被放在了错误的地方

### 被拒绝的遗赠 Refused Bequest

子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？

按传统说法，这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟

### 注释 Comments

当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余

## 构筑测试体系

