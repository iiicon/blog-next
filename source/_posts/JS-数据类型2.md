---
title: JS 数据类型(二)
date: 2019-01-10 01:41:07
categories: js
tags: [G, js, js数据类型]
comments: false
---

### 概述

#### key

对象就是一组键值对的集合，是一种无序的复合数据集合
对象 obj 的所有键名虽然看上去像数值，实际上都被自动转成了字符串，如果键名不符合标识名的条件，且也不是数字，则必须加上引号，否则就会报错

#### 对象的引用

如果不同的变量名指向同一个对象，那么他们都是这个对象的引用

#### 表达式还是语句

{ console.log(123) }是一个代码块，要解释为对象，最好在大括号前加上圆括号，因为圆括号里面只能是表达式，所以确保大括号只能解释为对象
这种差异在 eval 中显示的最为明显

    eval('{foo:1}')
    eval('({foo:1})')

### 属性的操作

#### 读取

有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。
obj.o obj['o'] 使用点 o 就是字符串，使用方括号 o 就是变量
如果 key 是数字，则只能使用方括号，点会报错，方括号里的数字会自动转换为字符串

#### 赋值

允许'后绑定'

#### 查看

查看一个对象本身的所有属性，可以用 Object.keys 方法

#### 删除

删除对象本身的属性用 delete, delete obj.o 成功后返回 true
只有一种情况 delete 返回 false 那就是该属性存在且不得删除
var obj = Object.defineProperty({}, 'p', {value: 1, configurable: false}) delete obj.p
delete 返回 true 之后并不能说明已经删除，比如继承的属性

#### in 运算符判断属性是否存在

in 和 hasOwnProperty() 可以查找自身的属性

#### for in 属性遍历

- 它遍历的是所有 enumerable 的属性，会跳过不可遍历的属性
- 它不仅遍历对象自身的属性，还遍历继承的属性

####数组的本质
typeof 返回 object
数组的特殊性体现在他的键名是按次序排列的一组整数
之所以能用数值取值是因为数值会被转换成字符串，赋值的时候也是
arr.0 的写法不合法，因为单独的数值不能作为标识符（identifier）

#### length

返回数组成员的个数
数组的数字键不需要连续，length 总是最大的下标加 1，这也表明数组是动态的数据结构，可以随时增减数组的成员
length 的最大值是 2^32-1
设置 length 的值会导致数组的变化，设为 0 就可以清空数组，大于当前数组个数用 undefined 填充，如果设置为不合法的值会报错
设置数组属性，不会影响数组的 length
如果设置的键名是超出范围的数值，则会自动转换为字符串

#### in

in 运算符也适用于数组，但是个人感觉没啥用，可以用来判断属性？

#### for in

for in 会遍历所有的键，包括属性，所以不推荐适用

#### 遍历

一般可以用 while for forEach

#### 数组的空位

当数组的两个逗号之间没有任何值，那么这个数组就存在空位 hole
delete arr[1] 会形成空位
空位虽然取值也是 undefined 但是和 undefined 是不一样的
数组的遍历方法 forEach for in 以及 Object.keys() 会跳过空位，undefined 不会

#### 类数组对象

如果一个对象的所有键名都是正整数或零，并且有 length 属性，他就是 array-like object
常见的类数组对象有 Dom 集合 函数的 arguments 对象 以及 i 字符串
数组的 slice 方法可以把类数组对象变成数组 Array.prototype.slice.call(arguments)

### 函数

#### 函数的声明

1 function
2 var x = function x() {} name x 一般自己不写但是这个在函数内部可以获取到而且可以除错，不至于显示匿名函数
3 new Function('x','y','return x+y') 这种方式没有人用

递归真是强大，体验了一把 fib 函数

由于函数和其他数据类型的地位平等，所以在 js 中又称为第一等公民

函数名也是会提升，js 引擎会把函数名视同为变量名

#### 函数的属性和方法

#####f.name 属性的一个用处就是获取参数函数的名字

##### f.length 获取函数参数的个数

length 属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）

##### f.toString() 返回字符串

#### 函数作用域

对于 var 命令来说，局部变量只能在函数内部，其他区块中都是全局变量，在函数内部，也会存在变量提升

##### 函数本身的作用域

函数本身也是一个值，也有自己的作用域，他的作用域和变量一样，就是其声明时所在的作用域，而不是调用时所在的作用域
当函数执行返回另一个函数的时候，就可以绑定当前函数的作用域，从而形成闭包

##### 参数

函数的参数不是必须的，js 允许省略参数
参数如果传的是原始类型的值那么传递方式的就是 pass by value，如果传的是复合类型的值，传递方式就是 pass by reference
arguments 对象包含了函数运行时所需要的全部参数，严格模式下他是只读的，他是一个类数组对象，可以用 arguments.callee 来调用自身函数，但是同样严格模式是禁用的

##### 闭包

为了得到函数内的局部变量，只有在函数内部在定义一个函数，再返回这个内部函数，就可以读取函数变量了
实质上闭包就是将函数内部和函数外部连接起来的一座桥梁
闭包的最大用处有两个，一个是可以读取函数内部的变量 两一个就是可以让这些变量始终保持在内存中
**闭包两大场景 返回另一个函数 封装对象的私有属性和私有方法**
注意太多的闭包对内存消耗很大，因此不能滥用闭包，否则会造成的性能问题

##### 立即调用的函数表达式 IIFE

function f(){}() 直接加上 () 是会报错

> JavaScript 引擎看到行首是 function 关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了

```
(function(){ /* code */  }());
// 或者
(function(){ /* code */  })();
```

所以只要可以让解释器以表达式来处理函数定义，就能产生同样的效果

```
var i = function(){}();
true && function(){}();
!function(){}();
+function(){}();
~function(){}();
-function(){}();
```

IIFE Immediately-Invoked Function Expression 的主要目的有两个
一个就是不用为函数命名，避免污染全局变量
二就是内部形成了一个独立的作用域，可以封装一些外部无法读取的私有变量
